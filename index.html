<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas Tree | Precision Control</title>

    <!-- ä½¿ç”¨ç³»ç»Ÿå­—ä½“ä»£æ›¿ Google Fontsï¼Œé¿å…é˜»å¡æ¸²æŸ“ -->

    <style>
        :root {
            --c-bg: #000000;
            --c-gold: #d4af37;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--c-bg);
            font-family: 'Times New Roman', Georgia, 'Noto Serif SC', serif;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        h1 {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-family: Georgia, 'Times New Roman', 'Noto Serif SC', serif;
            font-size: 56px;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(to bottom, #ffffff, var(--c-gold));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 4px 15px rgba(212, 175, 55, 0.4);
            pointer-events: auto;
        }

        .controls-wrapper {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
        }


        .hint-text {
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease, visibility 1s;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 2px solid var(--c-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            color: var(--c-gold);
            font-family: Georgia, 'Times New Roman', 'Noto Serif SC', serif;
            font-size: 14px;
            letter-spacing: 3px;
        }

        .error-msg {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 15px;
            text-align: center;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        .vision-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            opacity: 0;
            pointer-events: none;
            /* ä¸éœ€è¦é•œåƒç¿»è½¬ï¼Œå‰ç½®æ‘„åƒå¤´æœ¬èº«å·²æ˜¯é•œåƒ */
        }

        #debug-mode {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            pointer-events: none;
            text-align: left;
            line-height: 1.5;
        }

        /* è§†è§‰å‡†æ˜Ÿä¼˜åŒ–ï¼šå¢åŠ ä¸­å¿ƒé™æ­¢åŒºæŒ‡ç¤º */
        #hand-cursor {
            position: fixed;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            transition: border-color 0.2s;
        }

        /* åœ¨æ­»åŒºå†…æ˜¾ç¤ºä¸ºç»¿è‰²ï¼ˆå®‰å…¨ï¼‰ */
        #hand-cursor.safe-zone {
            border-color: rgba(100, 255, 100, 0.8);
            background: rgba(100, 255, 100, 0.2);
        }

        /* æ—‹è½¬åŒºæ˜¾ç¤ºä¸ºé‡‘è‰² */
        #hand-cursor.active-zone {
            border-color: rgba(212, 175, 55, 0.9);
        }

        /* æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #gesture-indicator {
            position: fixed;
            top: 80px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            pointer-events: none;
        }

        #gesture-indicator .gesture-name {
            font-size: 16px;
            font-weight: bold;
            color: var(--c-gold);
            margin-bottom: 5px;
        }

        #pinch-progress {
            width: 80px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        #pinch-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--c-gold), #fff);
            border-radius: 2px;
            transition: width 0.1s ease-out;
        }

        /* ===== æ‰‹æœºç«¯å“åº”å¼ä¼˜åŒ– ===== */
        @media (max-width: 768px) {
            h1 {
                font-size: 28px;
                top: 10px;
            }

            #debug-mode {
                display: none;
                /* æ‰‹æœºä¸Šéšè—è°ƒè¯•ä¿¡æ¯ */
            }

            #gesture-indicator {
                top: 50px;
                left: 10px;
                font-size: 10px;
            }

            #gesture-indicator .gesture-name {
                font-size: 14px;
            }

            .controls-wrapper {
                bottom: 20px;
            }

            .hint-text {
                font-size: 10px;
            }

            #hand-cursor {
                width: 24px;
                height: 24px;
            }
        }

        /* è¶…å°å±å¹•ï¼ˆæ‰‹æœºç«–å±ï¼‰ */
        @media (max-width: 480px) {
            h1 {
                font-size: 22px;
            }
        }

        /* æ•™ç¨‹å¼¹çª—å“åº”å¼ */
        #tutorial-overlay>div {
            max-height: 70vh;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            #tutorial-overlay h2 {
                font-size: 22px !important;
                margin-bottom: 10px !important;
            }

            #tutorial-overlay>div {
                max-width: 90% !important;
                font-size: 13px !important;
            }

            #tutorial-overlay button {
                padding: 14px 40px !important;
                font-size: 14px !important;
            }
        }
    </style>

    <!-- iOS 16.4 ä»¥ä¸‹å…¼å®¹æ€§ polyfill (æœ¬åœ°åŠ è½½ï¼Œé¿å…å¤–ç½‘è®¿é—®é—®é¢˜) -->
    <script src="./libs/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three/three.module.js",
                "three/addons/": "./libs/three/addons/",
                "@mediapipe/tasks-vision": "./libs/mediapipe/vision_bundle.mjs"
            }
        }
    </script>
</head>

<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">LOADING HOLIDAY MAGIC</div>
        <div id="loader-subtitle"
            style="color:rgba(255,255,255,0.5);font-size:12px;margin-top:10px;text-align:center;max-width:300px;"></div>
        <div id="loader-progress"
            style="width:200px;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;margin-top:15px;overflow:hidden;display:none;">
            <div id="loader-progress-bar"
                style="height:100%;width:0%;background:linear-gradient(90deg,#d4af37,#f0d060);border-radius:2px;transition:width 0.3s ease;">
            </div>
        </div>
        <div id="loader-timer" style="color:rgba(255,255,255,0.4);font-size:11px;margin-top:8px;"></div>
        <button id="loader-switch-btn"
            style="display:none;margin-top:20px;padding:10px 24px;background:rgba(255,255,255,0.1);border:1px solid rgba(212,175,55,0.5);color:#d4af37;font-size:13px;cursor:pointer;border-radius:20px;font-family:Georgia,'Times New Roman',serif;transition:all 0.3s ease;"
            onmouseover="this.style.background='rgba(212,175,55,0.2)'"
            onmouseout="this.style.background='rgba(255,255,255,0.1)'">â­ï¸ è·³è¿‡ï¼Œä½¿ç”¨é¼ æ ‡æ¨¡å¼</button>
        <div id="loader-error" class="error-msg"></div>
    </div>

    <div id="hand-cursor"></div>

    <div id="ui-container">
        <h1>Merry Christmas</h1>
        <div id="debug-mode">
            Mode: TREE<br>
            <span id="ai-status">Initializing AI...</span>
        </div>
        <div id="gesture-indicator">
            <div class="gesture-name" id="gesture-name">--</div>
            <div>Pinch Progress:</div>
            <div id="pinch-progress">
                <div id="pinch-progress-bar"></div>
            </div>
        </div>
        <div class="controls-wrapper">

            <div class="hint-text">â€˜Hâ€™ Hide | â€˜1/2/3â€™ Mode | Drag/Pinch | â€˜Mâ€™ Music</div>
        </div>
    </div>

    <div class="vision-container">
        <video id="webcam" style="width: 160px; height: 120px;" autoplay playsinline muted></video>
    </div>

    <!-- ç”¨æˆ·æ•™ç¨‹é®ç½© -->
    <div id="tutorial-overlay"
        style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.92);z-index:200;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff;font-family:Georgia,'Times New Roman',serif;">
        <h2 style="color:#d4af37;margin-bottom:20px;font-size:28px;">ğŸ„ æ¬¢è¿ä½“éªŒåœ£è¯æ ‘</h2>
        <p style="color:rgba(255,255,255,0.6);margin-bottom:20px;font-size:13px;">ç”¨æ‰‹åŠ¿æˆ–é¼ æ ‡ä¸3Dåœ£è¯æ ‘äº’åŠ¨</p>
        <div style="text-align:left;line-height:1.6;font-size:13px;max-width:420px;">
            <div
                style="margin-bottom:10px;padding:10px;background:rgba(100,200,255,0.15);border-radius:8px;border:1px solid rgba(100,200,255,0.3);">
                <strong style="color:#66ccff;">ğŸ‘‹ æ ¸å¿ƒç©æ³•</strong><br>
                <div style="margin-top:6px;">
                    <span>ğŸ¯ <b>ç§»åŠ¨æ‰‹æŒ</b> â†’ æ—‹è½¬åœ£è¯æ ‘è§†è§’</span><br>
                    <span style="opacity:0.7;font-size:12px;">æ‰‹å¾€ä¸Š/ä¸‹/å·¦/å³ç§»åŠ¨ï¼Œæ ‘å°±è·Ÿç€è½¬åŠ¨ï¼</span>
                </div>
            </div>
            <div style="margin-bottom:10px;padding:10px;background:rgba(212,175,55,0.1);border-radius:8px;">
                <strong style="color:#d4af37;">ğŸ¯ æ¨¡å¼åˆ‡æ¢</strong><br>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px 16px;margin-top:6px;">
                    <span>âœŠ <b>æ¡æ‹³</b> â†’ åœ£è¯æ ‘</span><br>
                    <span>ğŸ–ï¸ <b>å¼ å¼€æ‰‹</b> â†’ æ•£å¼€</span><br>
                    <span>â˜ï¸ <b>å‘ä¸ŠæŒ‡</b> â†’ èšç„¦ç…§ç‰‡</span><br>
                </div>
            </div>
            <div style="margin-bottom:10px;padding:10px;background:rgba(212,175,55,0.1);border-radius:8px;">
                <strong style="color:#d4af37;">âœ¨ ç‚«é…·ç‰¹æ•ˆ (è§¦å‘åæ ‘æœ¨å˜è‰²)</strong><br>
                <div style="display:grid;grid-template-columns:1fr;gap:4px;margin-top:6px;">
                    <span><span style="color:#ff6699">ğŸ¤Ÿ <b>ILoveYou</b> â†’ â¤ï¸ ç²‰çº¢çˆ±å¿ƒçˆ†ç‚¸</span></span>
                    <span><span style="color:#ffd700">ğŸ‘ <b>ç‚¹èµ</b> â†’ ğŸŒŸ é‡‘æ©™å½©è™¹å†²å‡»æ³¢</span></span>
                    <span><span style="color:#00ffff">âœŒï¸ <b>æ¯”è€¶</b> â†’ ğŸ’ é’è“èƒ½é‡å…‰æŸ</span></span>
                    <span><span style="color:#9be7ff">ğŸ‘ <b>å€’èµ</b> â†’ â„ï¸ å†°é›ªé£æš´</span></span>
                </div>
            </div>
            <div style="padding:10px;background:rgba(212,175,55,0.1);border-radius:8px;">
                <strong style="color:#d4af37;">ğŸ–±ï¸ è§¦æ§ / é¼ æ ‡ / âŒ¨ï¸ é”®ç›˜</strong><br>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px 16px;margin-top:6px;">
                    <span><b>æ‹–æ‹½</b> â†’ æ—‹è½¬è§†è§’</span>
                    <span><b>åŒæŒ‡æåˆ</b> â†’ ç¼©æ”¾</span>
                    <span><b>æ»šè½®</b> â†’ åˆ‡æ¢æ¨¡å¼</span>
                    <span><b>1/2/3</b> â†’ åˆ‡æ¢æ¨¡å¼</span>
                    <span><b>H</b> â†’ éšè—ç•Œé¢</span>
                    <span><b>M</b> â†’ éŸ³ä¹å¼€å…³</span>
                </div>
            </div>
            <div style="margin-top:10px;padding:10px;background:rgba(100,200,255,0.12);border-radius:8px;border:1px solid rgba(100,200,255,0.25);">
                <strong style="color:#66ccff;">ğŸ å½©è›‹è¿æ‹›</strong><br>
                <div style="margin-top:6px;line-height:1.6;">
                    <div>ğŸ¤Ÿ â†’ âœŒï¸ â†’ ğŸ‘ï¼šğŸ… é£è¿‡</div>
                    <div>ğŸ‘ğŸ‘ğŸ‘ï¼šğŸ ç¤¼ç‰©é›¨</div>
                    <div>âœŒï¸âœŒï¸ğŸ¤Ÿï¼šğŸ¨ æ¢ä¸»é¢˜ï¼ˆç»å…¸/å†°é›ª/ç³–æœï¼‰</div>
                </div>
                <div style="opacity:0.7;font-size:11px;margin-top:6px;">æç¤ºï¼šè¿æ‹›éœ€åœ¨çŸ­æ—¶é—´å†…å®Œæˆ</div>
            </div>
        </div>
        <button onclick="window.startWithGesture()"
            style="margin-top:25px;padding:14px 50px;background:linear-gradient(135deg,#d4af37,#f0d060);border:none;color:#000;font-size:16px;cursor:pointer;border-radius:25px;font-family:Georgia,'Times New Roman',serif;font-weight:bold;">ğŸ„
            å¼€å§‹ä½“éªŒ</button>
        <p style="color:rgba(255,255,255,0.4);margin-top:12px;font-size:11px;">éœ€ä¸‹è½½AIæ¨¡å‹(~8MB) | æ— æ‘„åƒå¤´è‡ªåŠ¨åˆ‡æ¢é¼ æ ‡æ¨¡å¼</p>
    </div>

    <!-- æŒä¹…æç¤ºé¢æ¿ï¼ˆå·¦ä¸‹è§’ï¼‰ -->
    <div id="hint-panel"
        style="position:fixed;bottom:20px;left:20px;background:rgba(0,0,0,0.7);border:1px solid rgba(212,175,55,0.3);border-radius:12px;padding:10px 14px;font-family:Georgia,'Times New Roman',serif;font-size:11px;color:rgba(255,255,255,0.8);z-index:50;max-width:200px;backdrop-filter:blur(5px);display:none;transition:all 0.3s ease;">
        <div id="hint-content" style="display:block;">
            <div style="color:#d4af37;font-weight:bold;margin-bottom:6px;cursor:pointer;" onclick="toggleHintPanel()">ğŸ“–
                æ“ä½œæç¤º <span style="float:right;opacity:0.5;">âˆ’</span></div>
            <div id="hint-details">
                <div style="margin-bottom:4px;color:#66ccff;"><b>ğŸ‘‹ æ ¸å¿ƒ:</b> ç§»åŠ¨æ‰‹æŒæ—‹è½¬è§†è§’</div>
                <div style="margin-bottom:4px;"><b>æ¨¡å¼:</b> âœŠæ”¶ç¼© | ğŸ–ï¸æ•£å¼€ | â˜ï¸æ˜¾ç¤ºç…§ç‰‡</div>
                <div style="margin-bottom:4px;"><b>ç‰¹æ•ˆ:</b> <span style="color:#ff6699">ğŸ¤Ÿç²‰çˆ±å¿ƒ</span> | <span
                        style="color:#ffd700">ğŸ‘é‡‘å½©è™¹</span> | <span style="color:#00ffff">âœŒï¸é’èƒ½é‡</span> | <span
                        style="color:#9be7ff">ğŸ‘å†°é›ª</span></div>
                <div><b>æ“ä½œ:</b> æ‹–æ‹½æ—‹è½¬ | åŒæŒ‡æåˆç¼©æ”¾ | æ»šè½®/1-3åˆ‡æ¢ | MéŸ³ä¹</div>
                <div style="margin-top:6px;opacity:0.9;"><b>å½©è›‹:</b> ğŸ¤Ÿâ†’âœŒï¸â†’ğŸ‘=ğŸ… | ğŸ‘ğŸ‘ğŸ‘=ğŸ | âœŒï¸âœŒï¸ğŸ¤Ÿ=ğŸ¨</div>
            </div>
        </div>
        <div id="hint-collapsed" style="display:none;cursor:pointer;color:#d4af37;" onclick="toggleHintPanel()">ğŸ“– <span
                style="opacity:0.5;">+</span></div>
    </div>

    <!-- ğŸµ éŸ³ä¹å¼€å…³æŒ‰é’®ï¼ˆå³ä¸‹è§’ï¼‰ -->
    <button id="music-toggle-btn" onclick="window.__ctAudioToggle && window.__ctAudioToggle()"
        style="position:fixed;bottom:20px;right:20px;width:50px;height:50px;border-radius:50%;border:2px solid rgba(212,175,55,0.6);background:rgba(0,0,0,0.7);color:#fff;font-size:24px;cursor:pointer;z-index:100;backdrop-filter:blur(5px);transition:all 0.3s ease;display:flex;align-items:center;justify-content:center;"
        title="åˆ‡æ¢éŸ³ä¹ (Mé”®)">ğŸ”Š</button>

    <script>
        // æ£€æµ‹æ˜¯å¦æ˜¯æ‰‹æœºè®¾å¤‡
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // Silent Service Worker registration (improves repeat-load speed). No UI, no logs.
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => { /* silent */ });
            });
        }

        // ===== æµè§ˆå™¨å…¼å®¹æ€§æ£€æµ‹ç³»ç»Ÿ =====
        const BrowserCompat = {
            ua: navigator.userAgent,

            // æ£€æµ‹å¾®ä¿¡/QQå†…ç½®æµè§ˆå™¨
            isWeChatOrQQ() {
                return /MicroMessenger|QQ\//i.test(this.ua);
            },

            // æ£€æµ‹ UC/ç™¾åº¦/æ‰‹æœºQQæµè§ˆå™¨ç­‰å›½äº§æµè§ˆå™¨
            isChinaBrowser() {
                return /UCBrowser|Quark|BaiduApp|baiduboxapp|SogouMobileBrowser/i.test(this.ua);
            },

            // è·å– iOS ç‰ˆæœ¬
            getIOSVersion() {
                const match = this.ua.match(/OS (\d+)_(\d+)/);
                return match ? parseFloat(match[1] + '.' + match[2]) : null;
            },

            // è·å– Android ç‰ˆæœ¬
            getAndroidVersion() {
                const match = this.ua.match(/Android\s+([\d.]+)/);
                return match ? parseFloat(match[1]) : null;
            },

            // æ£€æµ‹ Chrome ç‰ˆæœ¬
            getChromeVersion() {
                const match = this.ua.match(/Chrome\/(\d+)/);
                return match ? parseInt(match[1]) : null;
            },

            // ç»¼åˆè¯„ä¼°å…¼å®¹æ€§
            assess() {
                const result = {
                    level: 'good',     // good, warning, critical
                    messages: [],
                    tips: []
                };

                // å¾®ä¿¡/QQ å†…ç½®æµè§ˆå™¨
                if (this.isWeChatOrQQ()) {
                    result.level = 'critical';
                    result.messages.push('âš ï¸ æ£€æµ‹åˆ°å¾®ä¿¡/QQå†…ç½®æµè§ˆå™¨');
                    result.tips.push('è¯·ç‚¹å‡»å³ä¸Šè§’ â‹¯ é€‰æ‹©ã€Œåœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ã€');
                    result.tips.push('æ¨èä½¿ç”¨ Safari æˆ– Chrome');
                    return result;
                }

                // iOS ç‰ˆæœ¬æ£€æµ‹
                const iosVersion = this.getIOSVersion();
                if (iosVersion) {
                    if (iosVersion < 15) {
                        result.level = 'critical';
                        result.messages.push(`âš ï¸ iOS ${iosVersion} ç‰ˆæœ¬è¿‡ä½`);
                        result.tips.push('å»ºè®®å‡çº§åˆ° iOS 16 æˆ–æ›´é«˜ç‰ˆæœ¬');
                        result.tips.push('ä½ç‰ˆæœ¬å¯èƒ½æ— æ³•ä½¿ç”¨æ‰‹åŠ¿è¯†åˆ«');
                    } else if (iosVersion < 16.4) {
                        result.level = 'warning';
                        result.messages.push(`ğŸ“± iOS ${iosVersion} å…¼å®¹æ¨¡å¼`);
                        result.tips.push('æ‰‹åŠ¿è¯†åˆ«å°†ä½¿ç”¨ CPU æ¨¡å¼ï¼ˆè¾ƒæ…¢ï¼‰');
                        result.tips.push('å»ºè®®å‡çº§åˆ° iOS 17+ è·å¾—æœ€ä½³ä½“éªŒ');
                    }
                    return result;
                }

                // Android æ£€æµ‹
                const androidVersion = this.getAndroidVersion();
                if (androidVersion) {
                    if (androidVersion < 8) {
                        result.level = 'critical';
                        result.messages.push(`âš ï¸ Android ${androidVersion} ç‰ˆæœ¬è¿‡ä½`);
                        result.tips.push('å»ºè®®å‡çº§ç³»ç»Ÿæˆ–ä½¿ç”¨é¼ æ ‡æ¨¡å¼');
                    }

                    // å›½äº§æµè§ˆå™¨æç¤º
                    if (this.isChinaBrowser()) {
                        result.level = result.level === 'critical' ? 'critical' : 'warning';
                        result.messages.push('ğŸ’¡ æ£€æµ‹åˆ°ç¬¬ä¸‰æ–¹æµè§ˆå™¨');
                        result.tips.push('æ¨èä½¿ç”¨ Chrome / Edge è·å¾—æœ€ä½³ä½“éªŒ');
                    }

                    // Chrome ç‰ˆæœ¬
                    const chromeVer = this.getChromeVersion();
                    if (chromeVer && chromeVer < 90) {
                        result.level = 'warning';
                        result.messages.push(`æµè§ˆå™¨ç‰ˆæœ¬è¾ƒæ—§ (Chrome ${chromeVer})`);
                        result.tips.push('å»ºè®®æ›´æ–°æµè§ˆå™¨åˆ°æœ€æ–°ç‰ˆæœ¬');
                    }
                    return result;
                }

                return result;
            },

            // æ˜¾ç¤ºå…¼å®¹æ€§æç¤ºæ¨ªå¹…
            showBanner() {
                const result = this.assess();
                if (result.level === 'good') return; // å…¼å®¹æ€§è‰¯å¥½ï¼Œä¸æ˜¾ç¤ºæç¤º

                const banner = document.createElement('div');
                banner.id = 'compat-banner';

                const bgColor = result.level === 'critical'
                    ? 'rgba(255, 80, 80, 0.95)'
                    : 'rgba(255, 180, 50, 0.95)';
                const borderColor = result.level === 'critical' ? '#ff4444' : '#ffaa00';

                banner.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    background: ${bgColor};
                    color: #fff;
                    padding: 12px 16px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 13px;
                    z-index: 10000;
                    text-align: center;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                    border-bottom: 2px solid ${borderColor};
                `;

                let html = result.messages.map(m => `<div style="font-weight:bold;">${m}</div>`).join('');
                html += result.tips.map(t => `<div style="font-size:12px;opacity:0.9;margin-top:4px;">${t}</div>`).join('');

                // æ·»åŠ å…³é—­æŒ‰é’®ï¼ˆé™¤éæ˜¯å¾®ä¿¡/QQæµè§ˆå™¨çš„ä¸¥é‡è­¦å‘Šï¼‰
                if (!(result.level === 'critical' && this.isWeChatOrQQ())) {
                    html += `<button onclick="this.parentElement.remove()" style="
                        position: absolute;
                        right: 10px;
                        top: 50%;
                        transform: translateY(-50%);
                        background: rgba(255,255,255,0.2);
                        border: none;
                        color: #fff;
                        padding: 5px 10px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                    ">çŸ¥é“äº†</button>`;
                }

                banner.innerHTML = html;
                document.body.insertBefore(banner, document.body.firstChild);

                // éä¸¥é‡è­¦å‘Š 10 ç§’åè‡ªåŠ¨éšè—
                if (result.level === 'warning') {
                    setTimeout(() => {
                        if (banner.parentElement) {
                            banner.style.transition = 'opacity 0.5s, transform 0.5s';
                            banner.style.opacity = '0';
                            banner.style.transform = 'translateY(-100%)';
                            setTimeout(() => banner.remove(), 500);
                        }
                    }, 10000);
                }
            }
        };

        // é¡µé¢åŠ è½½åæ˜¾ç¤ºå…¼å®¹æ€§æç¤º
        document.addEventListener('DOMContentLoaded', () => {
            BrowserCompat.showBanner();
        });

        // AIåŠ è½½è¿›åº¦è¿½è¸ªç³»ç»Ÿ
        let aiLoadTimers = {
            startTime: 0,
            displayTimer: null,
            phase1Timer: null,  // 3ç§’åæ˜¾ç¤ºæç¤º
            phase2Timer: null,  // 8ç§’åæ˜¾ç¤ºè·³è¿‡æŒ‰é’®
            progressInterval: null
        };

        // è·å–åŠ è½½UIå…ƒç´ 
        function getLoaderElements() {
            return {
                loader: document.getElementById('loader'),
                text: document.querySelector('.loader-text'),
                subtitle: document.getElementById('loader-subtitle'),
                progress: document.getElementById('loader-progress'),
                progressBar: document.getElementById('loader-progress-bar'),
                timer: document.getElementById('loader-timer'),
                switchBtn: document.getElementById('loader-switch-btn'),
                error: document.getElementById('loader-error')
            };
        }

        // å¼€å§‹AIåŠ è½½è¿›åº¦æ˜¾ç¤º
        function startAILoadProgress() {
            aiLoadTimers.startTime = Date.now();
            const els = getLoaderElements();

            // è¶…æ—¶æ—¶é—´é…ç½®ï¼ˆåŠ å€åçš„å€¼ï¼‰
            const timeoutMs = isMobile ? 90000 : 50000;  // ç§»åŠ¨ç«¯90ç§’ï¼Œæ¡Œé¢ç«¯50ç§’

            // æ›´æ–°åŠ è½½æ–‡å­—
            els.text.textContent = 'LOADING AI MODEL';
            els.subtitle.textContent = 'é¦–æ¬¡åŠ è½½éœ€ä¸‹è½½çº¦8MB AIæ¨¡å‹...';

            // æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ¨¡æ‹Ÿè¿›åº¦ï¼‰
            els.progress.style.display = 'block';
            let progress = 0;
            aiLoadTimers.progressInterval = setInterval(() => {
                // æ¨¡æ‹Ÿè¿›åº¦ï¼Œæ…¢æ…¢å¢é•¿ä½†ä¸ä¼šåˆ°100%
                progress += (100 - progress) * 0.01;  // æ›´æ…¢çš„å¢é•¿é€Ÿåº¦
                if (progress > 95) progress = 95;
                els.progressBar.style.width = progress + '%';
            }, 500);

            // å®æ—¶æ˜¾ç¤ºåŠ è½½æ—¶é—´
            aiLoadTimers.displayTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - aiLoadTimers.startTime) / 1000);
                els.timer.textContent = `å·²åŠ è½½ ${elapsed} ç§’...`;
            }, 1000);

            // é˜¶æ®µ1: 5ç§’åæ˜¾ç¤ºæ›´è¯¦ç»†çš„æç¤º
            aiLoadTimers.phase1Timer = setTimeout(() => {
                if (isLoaderVisible()) {
                    els.subtitle.innerHTML = isMobile
                        ? 'æ­£åœ¨ä¸‹è½½AIæ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...<br><span style="font-size:10px;opacity:0.7">æ‰‹æœºç½‘ç»œå¯èƒ½è¾ƒæ…¢ï¼Œè¯·è€å¿ƒç­‰å¾…</span>'
                        : 'æ­£åœ¨ä¸‹è½½AIæ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...';
                }
            }, 5000);

            // é˜¶æ®µ2: è¶…æ—¶åæ˜¾ç¤ºè·³è¿‡æŒ‰é’®ï¼ˆç§»åŠ¨ç«¯90ç§’ï¼Œæ¡Œé¢ç«¯50ç§’ï¼‰
            aiLoadTimers.phase2Timer = setTimeout(() => {
                if (isLoaderVisible()) {
                    els.subtitle.innerHTML = isMobile
                        ? 'åŠ è½½æ—¶é—´è¶…å‡ºé¢„æœŸï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜<br><span style="font-size:10px;opacity:0.7">æ‚¨å¯ä»¥ç»§ç»­ç­‰å¾…æˆ–åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼</span>'
                        : 'åŠ è½½æ—¶é—´è¶…å‡ºé¢„æœŸ<br><span style="font-size:10px;opacity:0.7">æ‚¨å¯ä»¥ç»§ç»­ç­‰å¾…æˆ–åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼</span>';
                    els.switchBtn.style.display = 'block';
                    els.switchBtn.onclick = () => {
                        skipToMouseMode('ç”¨æˆ·é€‰æ‹©è·³è¿‡');
                    };
                }
            }, timeoutMs);
        }

        // æ£€æŸ¥åŠ è½½å™¨æ˜¯å¦å¯è§
        function isLoaderVisible() {
            const loader = document.getElementById('loader');
            return loader && getComputedStyle(loader).opacity !== '0' && loader.style.display !== 'none';
        }

        // è·³è¿‡åˆ°é¼ æ ‡æ¨¡å¼
        function skipToMouseMode(reason) {
            clearAILoadProgress();
            try { if (window.__ctAudioArm) window.__ctAudioArm(); } catch { }

            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => {
                loader.style.visibility = 'hidden';
                window.startMouseOnly();
            }, 500);
        }

        // æ¸…é™¤æ‰€æœ‰åŠ è½½è®¡æ—¶å™¨
        function clearAILoadProgress() {
            if (aiLoadTimers.displayTimer) {
                clearInterval(aiLoadTimers.displayTimer);
                aiLoadTimers.displayTimer = null;
            }
            if (aiLoadTimers.progressInterval) {
                clearInterval(aiLoadTimers.progressInterval);
                aiLoadTimers.progressInterval = null;
            }
            if (aiLoadTimers.phase1Timer) {
                clearTimeout(aiLoadTimers.phase1Timer);
                aiLoadTimers.phase1Timer = null;
            }
            if (aiLoadTimers.phase2Timer) {
                clearTimeout(aiLoadTimers.phase2Timer);
                aiLoadTimers.phase2Timer = null;
            }
        }

        // ä¿æŒå‘åå…¼å®¹ï¼šæ—§çš„è¶…æ—¶å‡½æ•°ç°åœ¨è°ƒç”¨æ–°ç³»ç»Ÿ
        function startAILoadTimeout() {
            startAILoadProgress();
        }

        function clearAILoadTimeout() {
            clearAILoadProgress();
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- Silent local music (procedural; no external assets) ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.master = null;
                this.isRunning = false;
                this.isMuted = false;
                this._timer = null; // scheduler timer
                this._nextNoteTime = 0;
                this._seqIdx = 0;
                this._lookaheadMs = 25;
                this._scheduleAheadTime = isMobile ? 0.12 : 0.18;
                this._bpm = isMobile ? 104 : 112;
                this._secPerBeat = 60 / this._bpm;
                this._visibilityHooked = false;
                this._fx = null;
                // Best-effort persisted mute state (no UI)
                try { this.isMuted = localStorage.getItem('ct_music_muted') === '1'; } catch { }
            }

            _getCtx() {
                if (this.ctx) return this.ctx;
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (!Ctx) return null;
                this.ctx = new Ctx({ latencyHint: 'interactive' });
                this.master = this.ctx.createGain();
                this.master.gain.value = this.isMuted ? 0 : (isMobile ? 0.20 : 0.25);

                // Lightweight â€œroomâ€ FX: gentle lowpass + subtle reverb (procedural impulse)
                const lp = this.ctx.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = isMobile ? 2800 : 3600;
                lp.Q.value = 0.7;

                const wet = this.ctx.createGain();
                const dry = this.ctx.createGain();
                wet.gain.value = isMobile ? 0.08 : 0.12;
                dry.gain.value = 1.0;

                const convolver = this.ctx.createConvolver();
                convolver.buffer = this._makeImpulse(this.ctx, isMobile ? 0.55 : 0.75, isMobile ? 1.6 : 2.2);

                // routing: master -> lp -> dry+wet -> destination
                this.master.connect(lp);
                lp.connect(dry);
                lp.connect(convolver);
                convolver.connect(wet);
                dry.connect(this.ctx.destination);
                wet.connect(this.ctx.destination);

                this._fx = { lp, dry, wet, convolver };
                return this.ctx;
            }

            _makeImpulse(ctx, durationSec, decay) {
                const rate = ctx.sampleRate;
                const length = Math.max(1, Math.floor(rate * durationSec));
                const buffer = ctx.createBuffer(2, length, rate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = buffer.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        const t = i / length;
                        // exponentially decaying noise
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
                    }
                }
                return buffer;
            }

            arm() {
                const ctx = this._getCtx();
                if (!ctx) return;
                // Resume must be triggered by a user gesture on iOS
                try {
                    if (ctx.state === 'suspended') ctx.resume().catch(() => { /* silent */ });
                } catch { }
            }

            start() {
                const ctx = this._getCtx();
                if (!ctx || this.isRunning) return;
                this.arm();
                this.isRunning = true;
                this._secPerBeat = 60 / this._bpm;
                this._nextNoteTime = ctx.currentTime + 0.05;
                this._seqIdx = 0;

                // A simplified â€œJingle Bellsâ€ style melody in C major (MIDI), with beat durations.
                // Durations are in beats (quarter note = 1).
                this._sequence = [
                    // E E E | E E E | E G C D E
                    { m: 64, d: 0.5 }, { m: 64, d: 0.5 }, { m: 64, d: 1.0 },
                    { m: 64, d: 0.5 }, { m: 64, d: 0.5 }, { m: 64, d: 1.0 },
                    { m: 64, d: 0.5 }, { m: 67, d: 0.5 }, { m: 60, d: 0.5 }, { m: 62, d: 0.5 }, { m: 64, d: 2.0 },
                    // F F F F | F E E E | E D D E D G
                    { m: 65, d: 0.5 }, { m: 65, d: 0.5 }, { m: 65, d: 0.5 }, { m: 65, d: 0.5 },
                    { m: 65, d: 0.5 }, { m: 64, d: 0.5 }, { m: 64, d: 0.5 }, { m: 64, d: 0.5 },
                    { m: 64, d: 0.5 }, { m: 62, d: 0.5 }, { m: 62, d: 0.5 }, { m: 64, d: 0.5 }, { m: 62, d: 0.5 }, { m: 67, d: 2.0 },
                    // loop spacer
                    { m: null, d: 1.0 }
                ];

                // Chord progression (C, F, G) by measure (4 beats each)
                this._chords = [
                    [60, 64, 67], // C
                    [65, 69, 72], // F
                    [67, 71, 74], // G
                    [60, 64, 67]  // C
                ];

                const scheduler = () => {
                    if (!this.isRunning || !this.ctx) return;
                    try { if (this.ctx.state === 'suspended') this.ctx.resume().catch(() => { /* silent */ }); } catch { }
                    const now = this.ctx.currentTime;
                    while (this._nextNoteTime < now + this._scheduleAheadTime) {
                        this._scheduleStep(this._nextNoteTime);
                        const step = this._sequence[this._seqIdx];
                        const durBeats = step ? step.d : 0.5;
                        this._nextNoteTime += durBeats * this._secPerBeat;
                        this._seqIdx = (this._seqIdx + 1) % this._sequence.length;
                    }
                };

                this._timer = setInterval(scheduler, this._lookaheadMs);

                if (!this._visibilityHooked) {
                    this._visibilityHooked = true;
                    document.addEventListener('visibilitychange', () => {
                        if (!this.ctx) return;
                        if (document.hidden) {
                            try { this.ctx.suspend().catch(() => { /* silent */ }); } catch { }
                        } else {
                            try { this.ctx.resume().catch(() => { /* silent */ }); } catch { }
                        }
                    }, { passive: true });
                }
            }

            // Returns a 0..1 pulse based on the last scheduled beat (for subtle visual sync)
            getPulse() {
                try {
                    if (!this.ctx || !this.isRunning || this.isMuted) return 0;
                    const t = this.ctx.currentTime;
                    const dt = t - (this._pulseAt || 0);
                    if (dt < 0) return 0;
                    // fast attack, exponential decay (tuned to feel like a gentle â€œbreathâ€)
                    return Math.max(0, Math.min(1, Math.exp(-dt * (isMobile ? 8 : 10))));
                } catch {
                    return 0;
                }
            }

            _midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            _playBell(midi, t0, durBeats) {
                if (midi == null) return;
                const ctx = this.ctx;
                const freq = this._midiToFreq(midi);
                const dur = Math.max(0.06, durBeats * this._secPerBeat * 0.92);

                // Two-osc â€œbellâ€: triangle + sine partial, slight detune
                const o1 = ctx.createOscillator();
                const o2 = ctx.createOscillator();
                o1.type = 'triangle';
                o2.type = 'sine';
                o1.frequency.setValueAtTime(freq, t0);
                o2.frequency.setValueAtTime(freq * 2.01, t0);

                const g = ctx.createGain();
                const level = isMobile ? 0.09 : 0.10;
                g.gain.setValueAtTime(0.0001, t0);
                g.gain.exponentialRampToValueAtTime(level, t0 + 0.01);
                g.gain.exponentialRampToValueAtTime(level * 0.35, t0 + 0.10);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

                // Slight shimmer via very gentle LFO on o1 detune (cheap)
                const lfo = ctx.createOscillator();
                const lfoGain = ctx.createGain();
                lfo.type = 'sine';
                lfo.frequency.value = 5.5;
                lfoGain.gain.value = 6; // cents
                lfo.connect(lfoGain);
                lfoGain.connect(o1.detune);

                o1.connect(g);
                o2.connect(g);
                g.connect(this.master);

                o1.start(t0);
                o2.start(t0);
                lfo.start(t0);
                o1.stop(t0 + dur + 0.03);
                o2.stop(t0 + dur + 0.03);
                lfo.stop(t0 + dur + 0.03);
            }

            _playBass(midi, t0) {
                const ctx = this.ctx;
                const freq = this._midiToFreq(midi);
                const dur = 0.45 * this._secPerBeat;

                const osc = ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, t0);

                const g = ctx.createGain();
                const level = isMobile ? 0.06 : 0.07;
                g.gain.setValueAtTime(0.0001, t0);
                g.gain.exponentialRampToValueAtTime(level, t0 + 0.02);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

                osc.connect(g);
                g.connect(this.master);
                osc.start(t0);
                osc.stop(t0 + dur + 0.02);
            }

            _playChord(t0, chord) {
                // Very soft pad using triangle, short attack, low volume (keeps CPU low)
                const ctx = this.ctx;
                const g = ctx.createGain();
                const level = isMobile ? 0.020 : 0.026;
                const dur = 2.0 * this._secPerBeat;
                g.gain.setValueAtTime(0.0001, t0);
                g.gain.exponentialRampToValueAtTime(level, t0 + 0.05);
                g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                g.connect(this.master);

                for (let i = 0; i < chord.length; i++) {
                    const osc = ctx.createOscillator();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(this._midiToFreq(chord[i]), t0);
                    osc.connect(g);
                    osc.start(t0);
                    osc.stop(t0 + dur + 0.03);
                }
            }

            _scheduleStep(t0) {
                const step = this._sequence[this._seqIdx];
                if (!step) return;

                // Swing feel on 8ths (subtle)
                const isEighth = Math.abs(step.d - 0.5) < 1e-6;
                const swing = isMobile ? 0.03 : 0.04; // seconds-ish fraction of beat
                const t = t0 + (isEighth && (this._seqIdx % 2 === 1) ? swing * this._secPerBeat : 0);

                // Melody
                this._playBell(step.m, t, step.d);
                // Mark pulse time for visual sync (use the step time, not "now")
                this._pulseAt = t0;

                // Harmony: change chord every 4 beats based on time
                const beatsFromStart = (t0 - (this._startTime || t0)) / this._secPerBeat;
                if (!this._startTime) this._startTime = t0;
                if (Math.floor(beatsFromStart) % 4 === 0 && (this._seqIdx % 2 === 0)) {
                    const chordIdx = (Math.floor(beatsFromStart / 4) | 0) % this._chords.length;
                    this._playChord(t0, this._chords[chordIdx]);
                    // bass root
                    const root = this._chords[chordIdx][0] - 12;
                    this._playBass(root, t0);
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                try { localStorage.setItem('ct_music_muted', this.isMuted ? '1' : '0'); } catch { }
                if (this.master) this.master.gain.value = this.isMuted ? 0 : (isMobile ? 0.20 : 0.25);
                // æ›´æ–°æŒ‰é’®å›¾æ ‡
                const btn = document.getElementById('music-toggle-btn');
                if (btn) btn.textContent = this.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            }
        }

        const audio = new AudioEngine();
        // Expose hooks for non-module scripts
        window.__ctAudioArm = () => { try { audio.arm(); audio.start(); } catch { } };
        window.__ctAudioToggle = () => {
            try {
                audio.arm(); // ç¡®ä¿ iOS ä¸Šèƒ½æ’­æ”¾
                if (!audio.isRunning) audio.start();
                audio.toggleMute();
            } catch { }
        };
        // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
        setTimeout(() => {
            const btn = document.getElementById('music-toggle-btn');
            if (btn) btn.textContent = audio.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        }, 100);


        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            colors: { gold: 0xd4af37, green: 0x0f3b1d, red: 0x8a0303 },
            // ç§»åŠ¨ç«¯é™ä½ç²’å­æ•°é‡ä»¥æå‡æ€§èƒ½
            particleCount: isMobile ? 400 : 800,
            dustCount: isMobile ? 800 : 1500,
            treeHeight: 45,
            maxRadius: 18,
            // ç§»åŠ¨ç«¯é™ä½ bloom æ•ˆæœæå‡æ€§èƒ½
            bloom: {
                strength: isMobile ? 0.35 : 0.45,
                radius: isMobile ? 0.3 : 0.4,
                threshold: isMobile ? 0.8 : 0.7
            },
            // æ‰‹åŠ¿æ§åˆ¶é…ç½®ï¼ˆç§»åŠ¨ç«¯ä¸æ¡Œé¢ç«¯åŸºæœ¬ä¸€è‡´ï¼Œä»…å¾®è°ƒï¼‰
            gesture: {
                deadZone: isMobile ? 0.18 : 0.2,       // ç§»åŠ¨ç«¯æ­»åŒºç•¥å°
                sensitivityX: isMobile ? 0.9 : 0.8,   // ç§»åŠ¨ç«¯Xè½´çµæ•åº¦ç•¥é«˜
                sensitivityY: isMobile ? 0.45 : 0.4,  // ç§»åŠ¨ç«¯Yè½´çµæ•åº¦ç•¥é«˜
                damping: 0.98                          // é˜»å°¼ä¿æŒä¸€è‡´
            }
        };

        // --- Hidden theme system (no UI): cycles materials/lights for extra variety ---
        const THEMES = [
            {
                id: 'classic',
                colors: { gold: 0xd4af37, green: 0x0f3b1d, red: 0x8a0303 },
                lights: { key: 0xd4af37, fill: 0x4444ff },
                bloomBase: isMobile ? 0.35 : 0.45
            },
            {
                id: 'icy',
                colors: { gold: 0x9be7ff, green: 0x0a2a3a, red: 0x2bbcff },
                lights: { key: 0x9be7ff, fill: 0x2bbcff },
                bloomBase: isMobile ? 0.32 : 0.42
            },
            {
                id: 'candy',
                colors: { gold: 0xff4d6d, green: 0x16a34a, red: 0xff0033 },
                lights: { key: 0xff4d6d, fill: 0x66ccff },
                bloomBase: isMobile ? 0.34 : 0.44
            }
        ];
        let THEME_INDEX = 0;

        const STATE = {
            mode: 'TREE',
            targetPhoto: null,
            hoveredPhoto: null,  // å½“å‰æ‚¬åœçš„ç…§ç‰‡ï¼ˆæœ€è¿‘çš„ç…§ç‰‡ï¼‰
            rotationVelocity: { x: 0, y: 0 },
            currentRotation: { x: 0, y: 0 },
            isControlsHidden: false,
            lastModeChangeTime: 0,
            isLowPerformance: false  // ä½æ€§èƒ½è®¾å¤‡æ ‡å¿—ï¼ˆç”± Vision.init è®¾ç½®ï¼‰
        };

        const lerp = (start, end, t) => start * (1 - t) + end * t;
        const randomRange = (min, max) => Math.random() * (max - min) + min;

        // --- ç²’å­ç³»ç»Ÿ ---
        class ParticleSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.particles = [];
                this.photos = []; // cache photo objects to avoid repeated filtering
                this._tmpWorldPos = new THREE.Vector3();
                this._tmpProjPos = new THREE.Vector3();
                // Music-reactive micro-dance: preselect a subset to keep CPU low (no per-frame allocations)
                this._dance = { indices: [], seeded: false, lastPulse: 0, tmpScale: new THREE.Vector3() };
                this.mainGroup = new THREE.Group();
                this.scene.add(this.mainGroup);
                this.initAssets();
                this.generateParticles();
                this.generateDust();
                this.createTopStar();  // æ·»åŠ æ ‘é¡¶æ˜Ÿ
                this.loadLocalPhotos();
            }

            initAssets() {
                this.matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.9 });
                this.matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.8, metalness: 0.1 });
                this.matOrnRed = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.3, roughness: 0.1, clearcoat: 1.0 });
                this.matOrnGold = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.gold, metalness: 0.7, roughness: 0.2, clearcoat: 0.8 });
                this.matFrame = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.3, metalness: 0.8 });
                this.geoBox = new THREE.BoxGeometry(1, 1, 1);
                this.geoSphere = new THREE.SphereGeometry(0.6, 16, 16);
                const path = new THREE.CatmullRomCurve3([new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0.5, 1.5, 0), new THREE.Vector3(1, 1.2, 0)]);
                this.geoCane = new THREE.TubeGeometry(path, 20, 0.15, 8, false);
                const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, 64, 64); ctx.fillStyle = '#f00';
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(64, 64); ctx.lineTo(32, 64); ctx.lineTo(-32, 0); ctx.fill();
                const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace;
                this.matCane = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.4 });
            }

            applyTheme(theme) {
                if (!theme || !theme.colors) return;
                // Update CONFIG colors (used by lights and later assets)
                CONFIG.colors.gold = theme.colors.gold;
                CONFIG.colors.green = theme.colors.green;
                CONFIG.colors.red = theme.colors.red;

                // Update materials in-place (no geometry rebuild)
                if (this.matGold?.color) this.matGold.color.setHex(theme.colors.gold);
                if (this.matGreen?.color) this.matGreen.color.setHex(theme.colors.green);
                if (this.matOrnRed?.color) this.matOrnRed.color.setHex(theme.colors.red);
                if (this.matOrnGold?.color) this.matOrnGold.color.setHex(theme.colors.gold);
                if (this.matFrame?.color) this.matFrame.color.setHex(theme.colors.gold);

                if (this.topStar?.material) {
                    const m = this.topStar.material;
                    if (m.color) m.color.setHex(theme.colors.gold);
                    if (m.emissive) m.emissive.setHex(theme.colors.gold);
                }
            }

            generateParticles() {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const type = Math.random();
                    let mesh, pType;
                    if (type < 0.6) { mesh = new THREE.Mesh(this.geoBox, Math.random() > 0.5 ? this.matGold : this.matGreen); pType = 'BOX'; }
                    else if (type < 0.85) { mesh = new THREE.Mesh(this.geoSphere, Math.random() > 0.5 ? this.matOrnGold : this.matOrnRed); pType = 'SPHERE'; }
                    else { mesh = new THREE.Mesh(this.geoCane, this.matCane); pType = 'CANE'; mesh.rotation.z = Math.random() * Math.PI; }
                    mesh.scale.setScalar(randomRange(0.5, 1.2));
                    mesh.userData = {
                        type: pType,
                        treePos: this.calculateTreePosition(i),
                        scatterPos: this.calculateScatterPosition(),
                        rotationSpeed: new THREE.Vector3(randomRange(-0.02, 0.02), randomRange(-0.02, 0.02), 0),
                        originalScale: mesh.scale.clone()
                    };
                    mesh.position.copy(mesh.userData.treePos);
                    mesh.castShadow = true; mesh.receiveShadow = true;
                    this.mainGroup.add(mesh); this.particles.push(mesh);
                }
                // Preselect dance indices (stable subset; mobile uses fewer)
                this._dance.indices = [];
                const n = Math.min(CONFIG.particleCount, this.particles.length);
                const sample = Math.min(n, isMobile ? 36 : 84);
                const step = Math.max(1, Math.floor(n / sample));
                for (let i = 0; i < n; i += step) this._dance.indices.push(i);
                this._dance.seeded = true;
            }

            generateDust() {
                const geo = new THREE.BufferGeometry(); const pos = [];
                for (let i = 0; i < CONFIG.dustCount; i++) { const p = this.calculateScatterPosition(); pos.push(p.x * 2, p.y * 2, p.z * 2); }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
                this.scene.add(this.dustSystem);
            }

            // æ ‘é¡¶å‘å…‰æ˜Ÿæ˜Ÿ
            createTopStar() {
                const starGeo = new THREE.IcosahedronGeometry(2.5, 0);
                const starMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.gold,
                    emissive: CONFIG.colors.gold,
                    emissiveIntensity: 0.8,
                    metalness: 0.9,
                    roughness: 0.1
                });
                this.topStar = new THREE.Mesh(starGeo, starMat);
                this.topStar.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
                this.mainGroup.add(this.topStar);
            }

            calculateTreePosition(index) {
                const t = index / CONFIG.particleCount;
                const angle = t * 50 * Math.PI;
                const r = CONFIG.maxRadius * (1 - t);
                return new THREE.Vector3(r * Math.cos(angle), (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2), r * Math.sin(angle));
            }

            calculateScatterPosition() {
                const r = randomRange(8, 25); const theta = randomRange(0, Math.PI * 2); const phi = randomRange(0, Math.PI);
                return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }

            addDefaultPhoto() {
                const c = document.createElement('canvas'); c.width = 512; c.height = 512;
                const x = c.getContext('2d'); x.fillStyle = '#0f3b1d'; x.fillRect(0, 0, 512, 512);
                x.strokeStyle = '#d4af37'; x.lineWidth = 20; x.strokeRect(20, 20, 472, 472);
                x.fillStyle = '#fff'; x.font = 'bold 60px Georgia'; x.textAlign = 'center'; x.textBaseline = 'middle';
                x.fillText("JOYEUX", 256, 200); x.fillText("NOEL", 256, 312);
                const t = new THREE.CanvasTexture(c); t.colorSpace = THREE.SRGBColorSpace; this.addPhoto(t);
            }

            // ä»æœåŠ¡å™¨ API åŠ¨æ€åŠ è½½ç…§ç‰‡
            async loadLocalPhotos() {
                // åŠ è½½å¹¶è°ƒæ•´å›¾ç‰‡å¤§å°
                const loadAndResizeImage = (url) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const size = 512;
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        // ä¿æŒæ¯”ä¾‹è£å‰ª
                        const scale = Math.max(size / img.width, size / img.height);
                        const w = img.width * scale;
                        const h = img.height * scale;
                        const x = (size - w) / 2;
                        const y = (size - h) / 2;
                        ctx.drawImage(img, x, y, w, h);
                        const tex = new THREE.CanvasTexture(canvas);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        resolve(tex);
                    };
                    img.onerror = () => reject(new Error(`Failed to load ${url}`));
                    img.src = url;
                });

                // ä» API æˆ–é™æ€æ–‡ä»¶è·å–ç…§ç‰‡åˆ—è¡¨
                let photoFiles = [];
                try {
                    // å…ˆå°è¯• APIï¼ˆæœ¬åœ°å¼€å‘æœåŠ¡å™¨ï¼‰
                    let response = await fetch('/api/photos');
                    if (!response.ok) throw new Error('API not available');
                    photoFiles = await response.json();
                } catch (e) {
                    // å›é€€åˆ°é™æ€ photos.jsonï¼ˆNetlify éƒ¨ç½²ï¼‰
                    try {
                        const response = await fetch('/photos.json');
                        photoFiles = await response.json();
                    } catch (e2) {
                        console.warn('No photos found, using default');
                        this.addDefaultPhoto();
                        return;
                    }
                }
                console.log(`ğŸ“· Found ${photoFiles.length} photos`);

                // é€ä¸ªåŠ è½½ç…§ç‰‡
                const addNext = async (index) => {
                    if (index >= photoFiles.length) return;
                    try {
                        const tex = await loadAndResizeImage(photoFiles[index]);
                        this.addPhoto(tex);
                    } catch (e) {
                        console.warn('Photo load failed:', photoFiles[index], e);
                    }
                    requestAnimationFrame(() => addNext(index + 1));
                };
                addNext(0);
            }

            addPhoto(texture) {
                const group = new THREE.Group();
                // å¤ç”¨å‡ ä½•ä½“å’Œæè´¨ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
                if (!this.photoGeo) {
                    this.photoGeo = new THREE.PlaneGeometry(3, 3);
                    this.frameGeo = new THREE.BoxGeometry(3.2, 3.2, 0.2);
                }
                const frame = new THREE.Mesh(this.frameGeo, this.matFrame);
                const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                const photo = new THREE.Mesh(this.photoGeo, photoMat);
                photo.position.z = 0.11;
                group.add(frame, photo);
                group.userData = {
                    type: 'PHOTO',
                    treePos: this.calculateTreePosition(Math.floor(Math.random() * CONFIG.particleCount)),
                    scatterPos: this.calculateScatterPosition(),
                    originalScale: new THREE.Vector3(1, 1, 1),
                    rotationSpeed: new THREE.Vector3(0.01, 0, 0),
                    photoMaterial: photoMat  // ä¿å­˜å¼•ç”¨ä»¥ä¾¿é«˜äº®
                };
                // ç›´æ¥æ·»åŠ è€Œä¸æ›¿æ¢ï¼ˆæ›´å¿«ï¼‰
                this.mainGroup.add(group);
                this.particles.push(group);
                this.photos.push(group);
            }

            update(time, pulse = 0) {
                // æ—‹è½¬é˜»å°¼ï¼šæŒç»­å‡é€Ÿç›´åˆ°åœæ­¢ï¼ˆæ¨¡æ‹Ÿæ‘©æ“¦åŠ›ï¼‰
                // ä»…åœ¨ä¸æ‹–æ‹½æ—¶åº”ç”¨é˜»å°¼
                // æƒ¯æ€§é˜»å°¼ï¼šæ¯å¸§é€Ÿåº¦è¡°å‡ï¼Œä½¿æ—‹è½¬è‡ªç„¶åœæ­¢
                const damping = CONFIG.gesture.damping;
                STATE.rotationVelocity.x *= damping;
                STATE.rotationVelocity.y *= damping;
                // é€Ÿåº¦è¿‡å°æ—¶å½’é›¶ï¼Œé¿å…æ— é™å¾®å°æ—‹è½¬
                if (Math.abs(STATE.rotationVelocity.x) < 0.001) STATE.rotationVelocity.x = 0;
                if (Math.abs(STATE.rotationVelocity.y) < 0.001) STATE.rotationVelocity.y = 0;

                // åº”ç”¨æ—‹è½¬é€Ÿåº¦ï¼ˆæ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´ä¹˜æ•°ï¼‰
                // - é«˜æ€§èƒ½è®¾å¤‡ï¼šå¸§ç‡é«˜(60fps)ï¼Œç”¨è¾ƒå°ä¹˜æ•°ä¿æŒå¹³æ»‘
                // - ä½æ€§èƒ½è®¾å¤‡ï¼šå¸§ç‡ä½(15fps)ï¼Œç”¨è¾ƒå¤§ä¹˜æ•°è¡¥å¿å“åº”é€Ÿåº¦
                const rotationMultiplier = STATE.isLowPerformance ? 0.15 : 0.05;
                this.mainGroup.rotation.y += STATE.rotationVelocity.x * rotationMultiplier;
                this.mainGroup.rotation.x += STATE.rotationVelocity.y * rotationMultiplier;

                // è¿½è¸ªå½“å‰æ—‹è½¬è§’åº¦ï¼ˆç”¨äºç›´æ¥è§’åº¦æ§åˆ¶ï¼‰
                STATE.currentRotation.x = this.mainGroup.rotation.x;
                STATE.currentRotation.y = this.mainGroup.rotation.y;

                if (this.dustSystem) this.dustSystem.rotation.y = time * 0.05;

                // æ ‘é¡¶æ˜Ÿæ—‹è½¬
                if (this.topStar) {
                    this.topStar.rotation.y = time * 0.5;
                    this.topStar.rotation.x = Math.sin(time) * 0.2;
                }

                // Music-reactive micro-dance (very subtle; auto-disables when muted or low-perf)
                // Only affects a small subset and never touches PHOTO groups.
                if (pulse > 0.001 && !STATE.isLowPerformance && this._dance && this._dance.seeded) {
                    const wobble = 0.03 + pulse * 0.08;
                    const rotWobble = 0.015 + pulse * 0.03;
                    const idxs = this._dance.indices;
                    const tmp = this._dance.tmpScale;
                    for (let k = 0; k < idxs.length; k++) {
                        const p = this.particles[idxs[k]];
                        if (!p || !p.userData || p.userData.type === 'PHOTO') continue;
                        const s0 = p.userData.originalScale;
                        // scale breathe
                        const f = 1 + Math.sin(time * 6 + idxs[k]) * wobble * 0.15 + pulse * 0.08;
                        tmp.set(s0.x * f, s0.y * f, s0.z * f);
                        p.scale.lerp(tmp, 0.08);
                        // tiny rotation shimmer
                        p.rotation.z += Math.sin(time * 4 + idxs[k]) * rotWobble * 0.02;
                    }
                }

                this.particles.forEach(p => {
                    let targetPos, targetScale;

                    // ç…§ç‰‡é«˜äº®é€»è¾‘
                    if (p.userData.type === 'PHOTO' && p.userData.photoMaterial) {
                        if (p === STATE.hoveredPhoto) {
                            // é«˜äº®æœ€è¿‘çš„ç…§ç‰‡
                            p.userData.photoMaterial.color.setHex(0xffffcc);
                        } else {
                            p.userData.photoMaterial.color.setHex(0xffffff);
                        }
                    }

                    if (STATE.mode === 'TREE') {
                        targetPos = p.userData.treePos; targetScale = p.userData.originalScale;
                        p.rotation.set(lerp(p.rotation.x, 0, 0.05), lerp(p.rotation.y, targetPos.x * 0.1, 0.05), lerp(p.rotation.z, 0, 0.05));
                    } else if (STATE.mode === 'SCATTER') {
                        targetPos = p.userData.scatterPos; targetScale = p.userData.originalScale;
                        p.rotation.x += p.userData.rotationSpeed.x; p.rotation.y += p.userData.rotationSpeed.y;
                    } else if (STATE.mode === 'FOCUS') {
                        if (p === STATE.targetPhoto) {
                            // ä½¿ç”¨å›ºå®šçš„ä¸–ç•Œåæ ‡ä½ç½®ï¼ˆå¤ç”¨å¯¹è±¡é¿å…GCï¼‰
                            this._focusWorldPos = this._focusWorldPos || new THREE.Vector3();
                            this._focusInvMatrix = this._focusInvMatrix || new THREE.Matrix4();
                            this._focusScale = this._focusScale || new THREE.Vector3(4.5, 4.5, 4.5);
                            this._focusWorldPos.set(0, 2, 35);
                            this._focusInvMatrix.copy(this.mainGroup.matrixWorld).invert();
                            targetPos = this._focusWorldPos.applyMatrix4(this._focusInvMatrix);
                            targetScale = this._focusScale;
                            p.lookAt(this.camera.position);
                        } else {
                            targetPos = p.userData.scatterPos.clone().multiplyScalar(1.5); targetScale = p.userData.originalScale;
                        }
                    }
                    p.position.lerp(targetPos, 0.03);
                    p.scale.lerp(targetScale, 0.05);
                });
            }

            pickRandomPhoto() {
                const photos = this.photos;
                if (photos.length > 0) return photos[(Math.random() * photos.length) | 0];
                return this.particles[0];
            }

            // æ ¹æ®å±å¹•ä½ç½®æ‰¾åˆ°æœ€è¿‘çš„ç…§ç‰‡
            findNearestPhoto(screenX, screenY, camera) {
                const photos = this.photos;
                if (photos.length === 0) return this.particles[0];

                // Ensure matrices are fresh for correct projection (findNearestPhoto can be called outside render)
                this.mainGroup.updateWorldMatrix(true, true);

                const w = window.innerWidth;
                const h = window.innerHeight;
                const worldPos = this._tmpWorldPos;
                const projPos = this._tmpProjPos;

                let nearest = photos[0];
                let minDist = Infinity;

                for (let i = 0; i < photos.length; i++) {
                    const photo = photos[i];
                    photo.getWorldPosition(worldPos);
                    projPos.copy(worldPos).project(camera);

                    const photoScreenX = (projPos.x + 1) * 0.5 * w;
                    const photoScreenY = (-projPos.y + 1) * 0.5 * h;

                    const dx = photoScreenX - screenX;
                    const dy = photoScreenY - screenY;
                    const d = Math.hypot(dx, dy);

                    if (d < minDist && projPos.z < 1) {
                        minDist = d;
                        nearest = photo;
                    }
                }

                return nearest;
            }
        }

        // --- æ‰‹åŠ¿ç‰¹æ•ˆç³»ç»Ÿ (ç‚«é…·ç‰ˆ - ç²’å­çˆ†ç‚¸ + å†²å‡»æ³¢) ---
        class GestureEffects {
            constructor(scene, particleSystem) {
                this.scene = scene;
                this.particleSystem = particleSystem;
                this.cooldowns = { ILoveYou: 0, ThumbUp: 0, Victory: 0, ThumbDown: 0 };
                // DOM pooling: reuse transient effect elements to reduce GC/layout churn (esp. mobile)
                this._pool = new Map(); // kind -> HTMLElement[]
                this._poolMax = isMobile ? 120 : 220;
                // rAF-driven emitter scheduler (reduces setTimeout storms for spawning)
                this._emitters = [];
                this.createOverlay();
            }

            // --- silent haptics (best-effort, no UI) ---
            haptic(pattern) {
                try {
                    if (navigator && typeof navigator.vibrate === 'function') navigator.vibrate(pattern);
                } catch { }
            }

            // --- DOM pool helpers ---
            _acquire(kind) {
                const key = kind || 'div';
                const list = this._pool.get(key);
                const el = list && list.length ? list.pop() : document.createElement('div');
                el.dataset.poolKind = key;
                // token prevents late timeouts from releasing a reused element
                el._poolToken = (el._poolToken || 0) + 1;
                return el;
            }

            _release(el) {
                if (!el) return;
                try { if (el.parentNode) el.parentNode.removeChild(el); } catch { }
                try { el.removeAttribute('style'); } catch { }
                try { el.className = ''; } catch { }
                try { el.textContent = ''; } catch { }
                const key = (el.dataset && el.dataset.poolKind) || 'div';
                // keep pool bounded
                let total = 0;
                for (const arr of this._pool.values()) total += arr.length;
                if (total >= this._poolMax) return;
                if (!this._pool.has(key)) this._pool.set(key, []);
                this._pool.get(key).push(el);
            }

            _releaseLater(el, ms, token) {
                const expected = token ?? el?._poolToken;
                setTimeout(() => {
                    if (!el) return;
                    if (expected != null && el._poolToken !== expected) return; // already reused
                    this._release(el);
                }, ms);
            }

            // --- emitter scheduler (spawn without timers; driven in update()) ---
            _scheduleEmitter({ count, intervalMs, durationMs, delayMs, maxCatchUp, spawn }) {
                const now = performance.now();
                this._emitters.push({
                    remaining: (count | 0) || 0,
                    intervalMs: Math.max(0, intervalMs | 0),
                    nextAt: now + (delayMs || 0),
                    endAt: now + (durationMs || 4000),
                    maxCatchUp: maxCatchUp || 3,
                    spawn
                });
            }

            createOverlay() {
                // åˆ›å»ºå…¨å±ç‰¹æ•ˆè¦†ç›–å±‚
                this.overlay = document.createElement('div');
                this.overlay.id = 'effect-overlay';
                this.overlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none;
                    z-index: 100;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    overflow: hidden;
                `;
                document.body.appendChild(this.overlay);

                // åˆ›å»ºä¸­å¿ƒç‰¹æ•ˆï¼ˆå¤§è¡¨æƒ…ï¼‰
                this.centerEffect = document.createElement('div');
                this.centerEffect.style.cssText = `
                    font-size: 200px;
                    opacity: 0;
                    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
                    text-shadow: 0 0 80px currentColor, 0 0 120px currentColor;
                    filter: drop-shadow(0 0 30px currentColor);
                    z-index: 10;
                `;
                this.overlay.appendChild(this.centerEffect);

                // åˆ›å»ºå†²å‡»æ³¢å®¹å™¨
                this.shockwaveContainer = document.createElement('div');
                this.shockwaveContainer.style.cssText = `
                    position: absolute;
                    top: 50%; left: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                `;
                this.overlay.appendChild(this.shockwaveContainer);

                // åˆ›å»ºç²’å­å®¹å™¨
                this.particleContainer = document.createElement('div');
                this.particleContainer.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none;
                `;
                this.overlay.appendChild(this.particleContainer);

                // åˆ›å»ºé—ªå…‰å±‚
                this.flashLayer = document.createElement('div');
                this.flashLayer.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; width: 100%; height: 100%;
                    opacity: 0;
                    pointer-events: none;
                    transition: opacity 0.1s ease;
                `;
                this.overlay.appendChild(this.flashLayer);

                // æ°›å›´è‰²è°ƒå±‚ï¼ˆæ›´â€œåœ£è¯ç¯å…‰â€æ°”æ°›ï¼›æ—  UIï¼›è‡ªåŠ¨æ·¡å‡ºï¼‰
                this.moodLayer = document.createElement('div');
                this.moodLayer.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; width: 100%; height: 100%;
                    opacity: 0;
                    pointer-events: none;
                    mix-blend-mode: screen;
                    filter: blur(10px);
                `;
                this.overlay.appendChild(this.moodLayer);
            }

            // ğŸ¤Ÿ ILoveYou - çˆ±å¿ƒé£æš´ + èŠ±ç“£é£˜è½ + æµªæ¼«ç¥ç¦
            triggerILoveYou(mode) {
                if (this.cooldowns.ILoveYou > 0) return;
                this.cooldowns.ILoveYou = 4000;
                this.haptic(isMobile ? 15 : 10);

                // å±å¹•éœ‡åŠ¨ï¼ˆç§»åŠ¨ç«¯å‡å¼±ï¼‰
                this.screenShake(isMobile ? 5 : 10);

                // ç²‰è‰²é—ªå…‰çˆ†ç‚¸
                this.flashBurst('#ff6699', '#ff1493');

                // ä¸­å¿ƒå¤§çˆ±å¿ƒï¼ˆå¸¦è„‰å†²ï¼‰
                this.showCenterEmoji('â¤ï¸', '#ff6699');

                // ğŸ†• çˆ±å¿ƒé£æš´ï¼šå¤šä¸ªå°çˆ±å¿ƒä»ä¸­å¿ƒé£å‡º
                this.createHeartStorm(isMobile ? 15 : 30);

                // ğŸ†• èŠ±ç“£é£˜è½æ•ˆæœ
                this.createFallingPetals(isMobile ? 20 : 40);

                // ğŸ†• æµªæ¼«ç¥ç¦æ–‡å­—
                this.showFloatingText('ğŸ’• Merry Christmas ğŸ’•', '#ff6699');

                // æå…‰æ•ˆæœï¼ˆä»æ ‘é¡¶å‘å‡ºï¼‰
                this.createAurora('#ff6699', '#ff1493');

                // å¤šå±‚æ‰©æ•£å†²å‡»æ³¢
                this.createShockwaves('#ff6699', isMobile ? 2 : 3);

                // å¿ƒå½¢å…‰ç¯
                this.createGlowRings('#ff6699', isMobile ? 2 : 4);

                // è®©3Dåœºæ™¯çš„ç²’å­ä¹Ÿå‘å…‰
                this.pulseTreeParticles('#ff6699');
            }

            // ğŸ‘ Thumb_Up - é‡‘å¸é›¨ + æ˜Ÿæ˜Ÿèºæ—‹ + åº†ç¥çƒŸèŠ±
            triggerThumbUp(mode) {
                if (this.cooldowns.ThumbUp > 0) return;
                this.cooldowns.ThumbUp = 4000;
                this.haptic(isMobile ? [10, 20, 10] : 10);

                // å±å¹•éœ‡åŠ¨ï¼ˆç§»åŠ¨ç«¯å‡å¼±ï¼‰
                this.screenShake(isMobile ? 5 : 10);

                // å½©è™¹é—ªå…‰
                this.rainbowFlashBurst();

                // ä¸­å¿ƒå¤§æ‹‡æŒ‡
                this.showCenterEmoji('ğŸ‘', '#ffd700');

                // ğŸ†• é‡‘å¸é›¨æ•ˆæœ
                this.createCoinRain(isMobile ? 15 : 25);

                // ğŸ†• æ˜Ÿæ˜Ÿèºæ—‹
                this.createStarSpiral(isMobile ? 12 : 20);

                // ğŸ†• åº†ç¥æ–‡å­—
                this.showFloatingText('â­ Amazing! â­', '#ffd700');

                // å½©è™¹æå…‰
                this.createAurora('#ffd700', '#ff8c00');

                // å½©è™¹å†²å‡»æ³¢
                this.createRainbowShockwave();

                // å½©è™¹è¾¹æ¡†è„‰å†²
                this.createPulsingBorder();

                // è®©3Dåœºæ™¯ç²’å­é—ªçƒ
                this.pulseTreeParticles('#ffd700');
            }

            // âœŒï¸ Victory - é’»çŸ³ç²’å­ + èƒ½é‡æ¼©æ¶¡ + èƒœåˆ©åº†å…¸
            triggerVictory(mode) {
                if (this.cooldowns.Victory > 0) return;
                this.cooldowns.Victory = 4000;
                this.haptic(isMobile ? [20, 30, 20] : 15);

                // å±å¹•éœ‡åŠ¨ï¼ˆç§»åŠ¨ç«¯å‡å¼±ï¼‰
                this.screenShake(isMobile ? 5 : 10);

                // é’è“è‰²é—ªå…‰
                this.flashBurst('#00ffff', '#0088ff');

                // ä¸­å¿ƒèƒœåˆ©æ‰‹åŠ¿
                this.showCenterEmoji('âœŒï¸', '#00ffff');

                // ğŸ†• é’»çŸ³ç²’å­é£æº…
                this.createDiamondSplash(isMobile ? 12 : 24);

                // ğŸ†• èƒ½é‡æ¼©æ¶¡
                this.createEnergyVortex();

                // ğŸ†• èƒœåˆ©æ–‡å­—
                this.showFloatingText('ğŸ† Victory! ğŸ†', '#00ffff');

                // é’è“æå…‰æ•ˆæœ
                this.createAurora('#00ffff', '#0088ff');

                // å…‰æŸæ•ˆæœï¼ˆç§»åŠ¨ç«¯å‡å°‘ï¼‰
                this.createLightBeams('#00ffff', isMobile ? 8 : 12);

                // èƒ½é‡å†²å‡»æ³¢
                this.createShockwaves('#00ffff', isMobile ? 1 : 2);

                // è®©3Dåœºæ™¯ç²’å­å˜é’è“è‰²
                this.pulseTreeParticles('#00ffff');
            }

            // ğŸ‘ Thumb_Down - å†°é›ªé£æš´ + å¯’å…‰é—ªçƒï¼ˆä¸æ”¹å˜æ¨¡å¼ï¼‰
            triggerThumbDown(mode) {
                if (this.cooldowns.ThumbDown > 0) return;
                this.cooldowns.ThumbDown = 4500;
                this.haptic(isMobile ? 12 : 8);

                // å±å¹•éœ‡åŠ¨ï¼ˆæ›´è½»ï¼‰
                this.screenShake(isMobile ? 3 : 6);

                // å†°è“é—ªå…‰
                this.flashBurst('#9be7ff', '#2bbcff');

                // ä¸­å¿ƒé›ªèŠ±
                this.showCenterEmoji('â„ï¸', '#9be7ff');

                // å†°é›ªé£æš´
                this.createSnowStorm(isMobile ? 18 : 36);

                // å†°è“æå…‰
                this.createAurora('#9be7ff', '#2bbcff');

                // è½»é‡å†²å‡»æ³¢
                this.createShockwaves('#9be7ff', 1);

                // 3D ç²’å­åå†·è‰²é—ªçƒ
                this.pulseTreeParticles('#9be7ff');
            }

            // ğŸ Hidden Easter Egg: Gift rain shower
            triggerGiftRain() {
                if (this.cooldowns.Gift && this.cooldowns.Gift > 0) return;
                this.cooldowns.Gift = 7000;

                // subtle celebration flash + border pulse (reuses existing)
                this.flashBurst('#ffd700', '#ff8c00');
                this.createPulsingBorder();
                // warm holiday mood + a touch of snow
                this.setMoodTint('#ffd700', '#ff4d6d', isMobile ? 1800 : 2200);
                this.createSnowStorm(isMobile ? 10 : 18);
                this.createGiftRain(isMobile ? 18 : 32);
            }

            // ğŸ›· Hidden Easter Egg: Santa flyby (no UI, just joy)
            triggerSantaFlyby() {
                // small cooldown to avoid spam
                if (this.cooldowns.Santa && this.cooldowns.Santa > 0) return;
                this.cooldowns.Santa = 6000;

                const santa = this._acquire('santa');
                const token = santa._poolToken;
                santa.textContent = 'ğŸ›·ğŸ…ğŸ';
                const top = 10 + Math.random() * 25;
                const duration = 2.8 + Math.random() * 0.8;
                santa.style.cssText = `
                    position: fixed;
                    top: ${top}%;
                    left: -30vw;
                    font-size: ${isMobile ? 34 : 42}px;
                    z-index: 180;
                    pointer-events: none;
                    filter: drop-shadow(0 0 14px rgba(255,215,0,0.45));
                    will-change: transform, opacity;
                    animation: santaFly ${duration}s linear forwards;
                `;
                this.overlay.appendChild(santa);
                this._releaseLater(santa, duration * 1000 + 200, token);

                // golden aurora tail mood (subtle)
                this.setMoodTint('#ffd700', '#ff8c00', isMobile ? 1600 : 1900);
                this.createAurora('#ffd700', '#ff8c00');

                // a few sparkles as trail
                this._scheduleEmitter({
                    count: isMobile ? 10 : 18,
                    intervalMs: 60,
                    durationMs: duration * 1000,
                    spawn: () => {
                        const sp = this._acquire('santaSpark');
                        const spToken = sp._poolToken;
                        sp.textContent = 'âœ¨';
                        sp.style.cssText = `
                            position: fixed;
                            top: ${top + (Math.random() - 0.5) * 8}%;
                            left: ${Math.random() * 15}%;
                            font-size: ${12 + Math.random() * 14}px;
                            opacity: 0;
                            z-index: 179;
                            pointer-events: none;
                            animation: santaSpark 1.2s ease-out forwards;
                            filter: drop-shadow(0 0 10px rgba(255,215,0,0.55));
                        `;
                        this.overlay.appendChild(sp);
                        this._releaseLater(sp, 1200, spToken);
                    }
                });
            }

            // å±å¹•éœ‡åŠ¨ï¼ˆå¯è°ƒèŠ‚å¼ºåº¦ï¼‰
            screenShake(intensity = 10) {
                const body = document.body;
                const originalTransform = body.style.transform;
                let shakeCount = 0;
                const shake = setInterval(() => {
                    const x = (Math.random() - 0.5) * intensity;
                    const y = (Math.random() - 0.5) * intensity;
                    body.style.transform = `translate(${x}px, ${y}px)`;
                    shakeCount++;
                    if (shakeCount > 10) {
                        clearInterval(shake);
                        body.style.transform = originalTransform || '';
                    }
                }, 30);
            }

            // ğŸŒˆ æå…‰æ•ˆæœï¼ˆä»å±å¹•ä¸Šæ–¹å‚ä¸‹ï¼‰
            createAurora(color1, color2) {
                const aurora = document.createElement('div');
                aurora.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 60%;
                    background: linear-gradient(
                        180deg,
                        ${color1}40 0%,
                        ${color2}30 20%,
                        ${color1}20 40%,
                        ${color2}10 60%,
                        transparent 100%
                    );
                    animation: auroraWave 2s ease-out forwards;
                    pointer-events: none;
                    filter: blur(20px);
                `;
                this.overlay.appendChild(aurora);
                setTimeout(() => aurora.remove(), 2000);

                // æ·»åŠ æ³¢åŠ¨æ¡çº¹
                for (let i = 0; i < 5; i++) {
                    const stripe = document.createElement('div');
                    stripe.style.cssText = `
                        position: absolute;
                        top: ${5 + i * 8}%;
                        left: ${10 + Math.random() * 20}%;
                        width: ${40 + Math.random() * 30}%;
                        height: 3px;
                        background: linear-gradient(90deg, transparent, ${i % 2 ? color1 : color2}80, transparent);
                        animation: auroraStripe ${1.5 + Math.random()}s ease-out forwards;
                        filter: blur(3px);
                        pointer-events: none;
                    `;
                    this.overlay.appendChild(stripe);
                    setTimeout(() => stripe.remove(), 2500);
                }
            }

            // ğŸ„ æ°›å›´ç¯å…‰ï¼šçŸ­æš‚æ•´ä½“åè‰²ï¼ˆæ—  UIï¼Œè‡ªåŠ¨æ¶ˆå¤±ï¼‰
            setMoodTint(color1, color2, durationMs = 2200) {
                if (!this.moodLayer) return;
                // restart animation on repeated triggers
                this.moodLayer.style.animation = 'none';
                this.moodLayer.style.background = `
                    radial-gradient(circle at 30% 20%, ${color1}55 0%, transparent 60%),
                    radial-gradient(circle at 70% 30%, ${color2}45 0%, transparent 65%),
                    radial-gradient(circle at 50% 80%, ${color1}25 0%, transparent 75%)
                `;
                void this.moodLayer.offsetWidth;
                this.moodLayer.style.animation = `moodTint ${durationMs}ms ease-out forwards`;
            }

            // è®©3Dåœºæ™¯çš„ç²’å­é—ªçƒï¼ˆè½»é‡çº§æ•ˆæœï¼‰
            pulseTreeParticles(colorHex) {
                if (!this.particleSystem || !this.particleSystem.particles) return;

                // è½¬æ¢é¢œè‰²
                const color = parseInt(colorHex.replace('#', ''), 16);

                // éšæœºé€‰å–éƒ¨åˆ†ç²’å­é—ªçƒï¼ˆä¸æ˜¯å…¨éƒ¨ï¼ŒèŠ‚çœæ€§èƒ½ï¼‰
                const particles = this.particleSystem.particles;
                const sampleCount = Math.min(particles.length, isMobile ? 30 : 60);
                const step = Math.floor(particles.length / sampleCount);

                for (let i = 0; i < particles.length; i += step) {
                    const p = particles[i];
                    if (!p || !p.material) continue;

                    const originalColor = p.material.color.getHex();
                    p.material.color.setHex(color);

                    // 1ç§’åæ¢å¤åŸè‰²
                    setTimeout(() => {
                        if (p.material) p.material.color.setHex(originalColor);
                    }, 1000);
                }
            }

            // é—ªå…‰çˆ†ç‚¸
            flashBurst(color1, color2) {
                this.flashLayer.style.background = `
                    radial-gradient(circle at center, 
                        ${color1} 0%, 
                        ${color2}80 30%, 
                        transparent 70%)
                `;
                this.flashLayer.style.opacity = '1';

                setTimeout(() => {
                    this.flashLayer.style.transition = 'opacity 0.6s ease-out';
                    this.flashLayer.style.opacity = '0';
                }, 100);

                setTimeout(() => {
                    this.flashLayer.style.transition = 'opacity 0.1s ease';
                }, 700);
            }

            // å½©è™¹é—ªå…‰çˆ†ç‚¸
            rainbowFlashBurst() {
                const colors = ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0077ff', '#7700ff'];
                let i = 0;
                const flash = setInterval(() => {
                    this.flashLayer.style.background = `
                        radial-gradient(circle at center,
                            ${colors[i]} 0%,
                            ${colors[(i + 1) % colors.length]}60 40%,
                            transparent 70%)
                    `;
                    this.flashLayer.style.opacity = '0.9';
                    i++;
                    if (i >= colors.length) {
                        clearInterval(flash);
                        this.flashLayer.style.transition = 'opacity 0.4s ease-out';
                        this.flashLayer.style.opacity = '0';
                    }
                }, 60);
            }

            // æ˜¾ç¤ºä¸­å¿ƒå¤§è¡¨æƒ…ï¼ˆå¸¦å¼¹è·³æ•ˆæœï¼‰
            showCenterEmoji(emoji, color) {
                this.centerEffect.textContent = emoji;
                this.centerEffect.style.color = color;
                this.centerEffect.style.opacity = '1';
                this.centerEffect.style.transform = 'scale(0.1) rotate(-20deg)';

                // å¼¹è·³æ”¾å¤§
                setTimeout(() => {
                    this.centerEffect.style.transform = 'scale(1.4) rotate(5deg)';
                }, 50);

                setTimeout(() => {
                    this.centerEffect.style.transform = 'scale(1) rotate(0deg)';
                }, 200);

                // è„‰å†²æ•ˆæœ
                setTimeout(() => {
                    this.centerEffect.style.transform = 'scale(1.1)';
                }, 600);

                setTimeout(() => {
                    this.centerEffect.style.transform = 'scale(1)';
                }, 800);

                // æ¸éšæ¶ˆå¤±
                setTimeout(() => {
                    this.centerEffect.style.opacity = '0';
                    this.centerEffect.style.transform = 'scale(2.5) rotate(10deg)';
                }, 1800);
            }

            // åˆ›å»ºå†²å‡»æ³¢
            createShockwaves(color, count) {
                this._scheduleEmitter({
                    count,
                    intervalMs: 150,
                    durationMs: 150 * count + 1400,
                    spawn: () => {
                        const wave = this._acquire('shockwave');
                        const token = wave._poolToken;
                        wave.style.cssText = `
                            position: absolute;
                            width: 50px;
                            height: 50px;
                            border: 4px solid ${color};
                            border-radius: 50%;
                            box-shadow: 0 0 30px ${color}, inset 0 0 20px ${color}40;
                            animation: shockwave 1.2s ease-out forwards;
                        `;
                        this.shockwaveContainer.appendChild(wave);
                        this._releaseLater(wave, 1200, token);
                    }
                });
            }

            // å½©è™¹å†²å‡»æ³¢
            createRainbowShockwave() {
                const wave = this._acquire('rainbowWave');
                const token = wave._poolToken;
                wave.style.cssText = `
                    position: absolute;
                    width: 50px;
                    height: 50px;
                    border: 6px solid transparent;
                    border-radius: 50%;
                    background: linear-gradient(45deg, #ff0000, #ff7700, #ffff00, #00ff00, #0077ff, #7700ff) border-box;
                    -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
                    -webkit-mask-composite: xor;
                    mask-composite: exclude;
                    animation: rainbowWave 1.5s ease-out forwards;
                    filter: blur(1px);
                `;
                this.shockwaveContainer.appendChild(wave);
                this._releaseLater(wave, 1500, token);
            }

            // ç²’å­çˆ†ç‚¸
            createParticleExplosion(color1, color2, count) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                for (let i = 0; i < count; i++) {
                    const particle = this._acquire('particle');
                    const token = particle._poolToken;
                    const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                    const distance = 150 + Math.random() * 400;
                    const size = 4 + Math.random() * 12;
                    const duration = 0.8 + Math.random() * 0.8;
                    const color = Math.random() > 0.5 ? color1 : color2;

                    particle.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        background: ${color};
                        border-radius: 50%;
                        left: ${centerX}px;
                        top: ${centerY}px;
                        box-shadow: 0 0 ${size * 2}px ${color}, 0 0 ${size * 4}px ${color}80;
                        animation: particleBurst ${duration}s ease-out forwards;
                        --tx: ${Math.cos(angle) * distance}px;
                        --ty: ${Math.sin(angle) * distance}px;
                    `;
                    this.particleContainer.appendChild(particle);
                    this._releaseLater(particle, duration * 1000, token);
                }
            }

            // å‘å…‰ç¯
            createGlowRings(color, count) {
                this._scheduleEmitter({
                    count,
                    intervalMs: 200,
                    durationMs: 200 * count + 1700,
                    spawn: () => {
                        const ring = this._acquire('glowRing');
                        const token = ring._poolToken;
                        ring.style.cssText = `
                            position: absolute;
                            top: 50%; left: 50%;
                            transform: translate(-50%, -50%);
                            width: 100px;
                            height: 100px;
                            border: 3px solid ${color};
                            border-radius: 50%;
                            box-shadow: 0 0 40px ${color}, 0 0 80px ${color}60;
                            animation: glowRing 1.5s ease-out forwards;
                        `;
                        this.overlay.appendChild(ring);
                        this._releaseLater(ring, 1500, token);
                    }
                });
            }

            // å…‰æŸ
            createLightBeams(color, count) {
                for (let i = 0; i < count; i++) {
                    const beam = this._acquire('beam');
                    const token = beam._poolToken;
                    const angle = (i / count) * 360;
                    beam.style.cssText = `
                        position: absolute;
                        top: 50%; left: 50%;
                        width: 8px;
                        height: 0;
                        background: linear-gradient(to top, ${color}, ${color}80, transparent);
                        transform-origin: bottom center;
                        transform: rotate(${angle}deg) translateX(-50%);
                        animation: beamShoot 0.8s ease-out forwards;
                        border-radius: 4px;
                        box-shadow: 0 0 20px ${color};
                    `;
                    this.overlay.appendChild(beam);
                    this._releaseLater(beam, 1000, token);
                }
            }

            // è„‰å†²è¾¹æ¡†
            createPulsingBorder() {
                const border = this._acquire('borderPulse');
                const token = border._poolToken;
                border.style.cssText = `
                    position: absolute;
                    top: 0; left: 0; right: 0; bottom: 0;
                    border: 6px solid transparent;
                    background: linear-gradient(45deg, #ff0000, #ff7700, #ffff00, #00ff00, #0077ff, #7700ff, #ff0000) border-box;
                    -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
                    -webkit-mask-composite: xor;
                    mask-composite: exclude;
                    animation: borderPulse 2s ease-in-out;
                    pointer-events: none;
                `;
                this.overlay.appendChild(border);
                this._releaseLater(border, 2000, token);
            }

            // ğŸ†• çˆ±å¿ƒé£æš´ï¼šå¤šä¸ªå°çˆ±å¿ƒä»ä¸­å¿ƒé£å‡º
            createHeartStorm(count) {
                const hearts = ['â¤ï¸', 'ğŸ’•', 'ğŸ’—', 'ğŸ’–', 'ğŸ’'];
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                this._scheduleEmitter({
                    count,
                    intervalMs: 30,
                    durationMs: 30 * count + 1800,
                    spawn: () => {
                        const heart = this._acquire('heart');
                        const token = heart._poolToken;
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 200 + Math.random() * 300;
                        const size = 20 + Math.random() * 30;
                        const duration = 1 + Math.random() * 0.5;

                        heart.textContent = hearts[(Math.random() * hearts.length) | 0];
                        heart.style.cssText = `
                            position: absolute;
                            left: ${centerX}px;
                            top: ${centerY}px;
                            font-size: ${size}px;
                            pointer-events: none;
                            z-index: 200;
                            animation: heartFly ${duration}s ease-out forwards;
                            --tx: ${Math.cos(angle) * distance}px;
                            --ty: ${Math.sin(angle) * distance}px;
                            --rot: ${(Math.random() - 0.5) * 720}deg;
                        `;
                        this.overlay.appendChild(heart);
                        this._releaseLater(heart, duration * 1000, token);
                    }
                });
            }

            // ğŸ†• èŠ±ç“£é£˜è½æ•ˆæœ
            createFallingPetals(count) {
                const petals = ['ğŸŒ¸', 'ğŸŒº', 'ğŸ’®', 'ğŸµï¸'];

                this._scheduleEmitter({
                    count,
                    intervalMs: 80,
                    durationMs: 80 * count + 2600,
                    spawn: () => {
                        const petal = this._acquire('petal');
                        const token = petal._poolToken;
                        const startX = Math.random() * window.innerWidth;
                        const size = 15 + Math.random() * 20;
                        const duration = 2 + Math.random() * 2;
                        const swayAmount = 50 + Math.random() * 100;

                        petal.textContent = petals[(Math.random() * petals.length) | 0];
                        petal.style.cssText = `
                            position: absolute;
                            left: ${startX}px;
                            top: -50px;
                            font-size: ${size}px;
                            pointer-events: none;
                            z-index: 150;
                            animation: petalFall ${duration}s ease-in-out forwards;
                            --sway: ${swayAmount}px;
                        `;
                        this.overlay.appendChild(petal);
                        this._releaseLater(petal, duration * 1000, token);
                    }
                });
            }

            // ğŸ†• æµ®åŠ¨ç¥ç¦æ–‡å­—
            showFloatingText(text, color) {
                const textEl = this._acquire('floatText');
                const token = textEl._poolToken;
                textEl.textContent = text;
                textEl.style.cssText = `
                    position: absolute;
                    top: 70%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 28px;
                    font-weight: bold;
                    color: ${color};
                    text-shadow: 0 0 20px ${color}, 0 0 40px ${color}80;
                    pointer-events: none;
                    z-index: 200;
                    white-space: nowrap;
                    animation: floatUp 2.5s ease-out forwards;
                `;
                this.overlay.appendChild(textEl);
                this._releaseLater(textEl, 2500, token);
            }

            // ğŸ†• é‡‘å¸é›¨æ•ˆæœ
            createCoinRain(count) {
                const coins = ['ğŸª™', 'ğŸ’°', 'â­', 'âœ¨'];

                this._scheduleEmitter({
                    count,
                    intervalMs: 60,
                    durationMs: 60 * count + 2200,
                    spawn: () => {
                        const coin = this._acquire('coin');
                        const token = coin._poolToken;
                        const startX = Math.random() * window.innerWidth;
                        const size = 25 + Math.random() * 20;
                        const duration = 1.5 + Math.random() * 1;

                        coin.textContent = coins[(Math.random() * coins.length) | 0];
                        coin.style.cssText = `
                            position: absolute;
                            left: ${startX}px;
                            top: -50px;
                            font-size: ${size}px;
                            pointer-events: none;
                            z-index: 150;
                            animation: coinDrop ${duration}s ease-in forwards;
                            --spin: ${Math.random() > 0.5 ? 360 : -360}deg;
                        `;
                        this.overlay.appendChild(coin);
                        this._releaseLater(coin, duration * 1000, token);
                    }
                });
            }

            // ğŸ ç¤¼ç‰©é›¨ï¼ˆå½©è›‹ç”¨ï¼Œæ€§èƒ½å‹å¥½ï¼šèµ° emitter + poolï¼‰
            createGiftRain(count) {
                const gifts = ['ğŸ', 'ğŸ„', 'ğŸ§¸', 'ğŸ¬', 'ğŸ§¦'];
                this._scheduleEmitter({
                    count,
                    intervalMs: 55,
                    durationMs: 55 * count + 2400,
                    spawn: () => {
                        const gift = this._acquire('gift');
                        const token = gift._poolToken;
                        const startX = Math.random() * window.innerWidth;
                        const size = 26 + Math.random() * 18;
                        const duration = 1.7 + Math.random() * 1.0;
                        const dx = (Math.random() - 0.5) * (isMobile ? 80 : 160);

                        gift.textContent = gifts[(Math.random() * gifts.length) | 0];
                        gift.style.cssText = `
                            position: absolute;
                            left: ${startX}px;
                            top: -60px;
                            font-size: ${size}px;
                            pointer-events: none;
                            z-index: 160;
                            opacity: 0;
                            filter: drop-shadow(0 0 10px rgba(255,215,0,0.45));
                            animation: giftDrop ${duration}s ease-in forwards;
                            --spin: ${Math.random() > 0.5 ? 360 : -360}deg;
                            --dx: ${dx}px;
                        `;
                        this.overlay.appendChild(gift);
                        this._releaseLater(gift, duration * 1000 + 50, token);
                    }
                });
            }

            // ğŸ†• æ˜Ÿæ˜Ÿèºæ—‹
            createStarSpiral(count) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                for (let i = 0; i < count; i++) {
                    const star = this._acquire('star');
                    const token = star._poolToken;
                    const angle = (i / count) * Math.PI * 4; // ä¸¤åœˆèºæ—‹
                    const radius = 50 + i * 15;
                    const delay = i * 50;
                    const size = 15 + Math.random() * 15;

                    star.textContent = 'â­';
                    star.style.cssText = `
                        position: absolute;
                        left: ${centerX}px;
                        top: ${centerY}px;
                        font-size: ${size}px;
                        pointer-events: none;
                        z-index: 200;
                        opacity: 0;
                        animation: starSpiral 1.5s ease-out ${delay}ms forwards;
                        --tx: ${Math.cos(angle) * radius}px;
                        --ty: ${Math.sin(angle) * radius}px;
                    `;
                    this.overlay.appendChild(star);
                    this._releaseLater(star, 2000 + delay, token);
                }
            }

            // ğŸ†• é’»çŸ³ç²’å­é£æº…
            createDiamondSplash(count) {
                const gems = ['ğŸ’', 'ğŸ’ ', 'ğŸ”·', 'ğŸ”¹'];
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                this._scheduleEmitter({
                    count,
                    intervalMs: 40,
                    durationMs: 40 * count + 1200,
                    spawn: () => {
                        const gem = this._acquire('gem');
                        const token = gem._poolToken;
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 150 + Math.random() * 250;
                        const size = 20 + Math.random() * 25;
                        const duration = 0.8 + Math.random() * 0.4;

                        gem.textContent = gems[(Math.random() * gems.length) | 0];
                        gem.style.cssText = `
                            position: absolute;
                            left: ${centerX}px;
                            top: ${centerY}px;
                            font-size: ${size}px;
                            pointer-events: none;
                            z-index: 200;
                            filter: drop-shadow(0 0 10px #00ffff);
                            animation: gemSplash ${duration}s ease-out forwards;
                            --tx: ${Math.cos(angle) * distance}px;
                            --ty: ${Math.sin(angle) * distance}px;
                        `;
                        this.overlay.appendChild(gem);
                        this._releaseLater(gem, duration * 1000, token);
                    }
                });
            }

            // ğŸ†• èƒ½é‡æ¼©æ¶¡
            createEnergyVortex() {
                const vortex = this._acquire('vortex');
                const vortexToken = vortex._poolToken;
                vortex.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 300px;
                    height: 300px;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 180;
                    border-radius: 50%;
                    background: conic-gradient(
                        from 0deg,
                        transparent 0deg,
                        #00ffff40 30deg,
                        transparent 60deg,
                        #0088ff40 90deg,
                        transparent 120deg,
                        #00ffff40 150deg,
                        transparent 180deg,
                        #0088ff40 210deg,
                        transparent 240deg,
                        #00ffff40 270deg,
                        transparent 300deg,
                        #0088ff40 330deg,
                        transparent 360deg
                    );
                    animation: vortexSpin 1.5s ease-out forwards;
                `;
                this.overlay.appendChild(vortex);
                this._releaseLater(vortex, 1500, vortexToken);

                // å†…åœˆæ¼©æ¶¡
                const innerVortex = this._acquire('innerVortex');
                const innerToken = innerVortex._poolToken;
                innerVortex.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 150px;
                    height: 150px;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 181;
                    border-radius: 50%;
                    border: 3px solid #00ffff;
                    box-shadow: 0 0 30px #00ffff, inset 0 0 30px #00ffff40;
                    animation: vortexSpinReverse 1s ease-out forwards;
                `;
                this.overlay.appendChild(innerVortex);
                this._releaseLater(innerVortex, 1500, innerToken);
            }

            update(deltaTime, time) {
                // æ›´æ–°å†·å´
                for (let key in this.cooldowns) {
                    if (this.cooldowns[key] > 0) {
                        this.cooldowns[key] -= deltaTime * 1000;
                    }
                }

                // Drive scheduled emitters (spawn without timers)
                if (this._emitters && this._emitters.length) {
                    const now = performance.now();
                    for (let i = this._emitters.length - 1; i >= 0; i--) {
                        const em = this._emitters[i];
                        if (!em || now > em.endAt || em.remaining <= 0) {
                            this._emitters.splice(i, 1);
                            continue;
                        }
                        let spawned = 0;
                        while (now >= em.nextAt && em.remaining > 0 && spawned < em.maxCatchUp) {
                            try { em.spawn && em.spawn(); } catch { }
                            em.remaining--;
                            spawned++;
                            em.nextAt += em.intervalMs;
                        }
                    }
                }
            }

            // â„ï¸ å†°é›ªé£æš´ï¼ˆå…¨å±é›ªèŠ±æ¼‚è½ï¼‰
            createSnowStorm(count = 24) {
                const snowflakes = ['â„ï¸', 'â…', 'â†'];
                this._scheduleEmitter({
                    count,
                    intervalMs: 35,
                    durationMs: 35 * count + 2800,
                    spawn: () => {
                        const flake = this._acquire('snow');
                        const token = flake._poolToken;
                        flake.textContent = snowflakes[(Math.random() * snowflakes.length) | 0];
                        const size = 14 + Math.random() * (isMobile ? 12 : 20);
                        const duration = 2.4 + Math.random() * 2.2;
                        const dx = (Math.random() - 0.5) * (isMobile ? 120 : 220);
                        flake.style.cssText = `
                            position: absolute;
                            top: -10vh;
                            left: ${Math.random() * 100}%;
                            font-size: ${size}px;
                            opacity: 0;
                            transform: translate3d(0,0,0);
                            filter: drop-shadow(0 0 10px rgba(155,231,255,0.6));
                            will-change: transform, opacity;
                            --dx: ${dx}px;
                            animation: snowFall ${duration}s linear forwards;
                            pointer-events: none;
                        `;
                        this.overlay.appendChild(flake);
                        this._releaseLater(flake, duration * 1000 + 200, token);
                    }
                });
            }
        }

        // æ·»åŠ CSSåŠ¨ç”» (ç‚«é…·ç‰¹æ•ˆ)
        const effectStyles = document.createElement('style');
        effectStyles.textContent = `
            @keyframes shockwave {
                0% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
                100% { 
                    transform: translate(-50%, -50%) scale(20); 
                    opacity: 0; 
                }
            }
            @keyframes rainbowWave {
                0% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
                100% { 
                    transform: translate(-50%, -50%) scale(25); 
                    opacity: 0; 
                }
            }
            @keyframes particleBurst {
                0% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
                100% { 
                    transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.3); 
                    opacity: 0; 
                }
            }
            @keyframes glowRing {
                0% { 
                    transform: translate(-50%, -50%) scale(1); 
                    opacity: 1; 
                }
                100% { 
                    transform: translate(-50%, -50%) scale(8); 
                    opacity: 0; 
                }
            }
            @keyframes beamShoot {
                0% { 
                    height: 0; 
                    opacity: 1; 
                }
                50% { 
                    height: 400px; 
                    opacity: 1; 
                }
                100% { 
                    height: 400px; 
                    opacity: 0; 
                }
            }
            @keyframes auroraWave {
                0% { 
                    opacity: 0;
                    transform: translateY(-20%);
                }
                30% { 
                    opacity: 1;
                }
                100% { 
                    opacity: 0;
                    transform: translateY(10%);
                }
            }
            @keyframes auroraStripe {
                0% { 
                    opacity: 0;
                    transform: scaleX(0.5);
                }
                30% { 
                    opacity: 1;
                    transform: scaleX(1);
                }
                100% { 
                    opacity: 0;
                    transform: scaleX(1.2) translateY(50px);
                }
            }
            @keyframes borderPulse {
                0% { opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { opacity: 0; }
            }

            @keyframes moodTint {
                0% { opacity: 0; transform: scale(1.02); }
                15% { opacity: 0.9; }
                100% { opacity: 0; transform: scale(1.06); }
            }
            
            /* ğŸ†• æ–°å¢åˆ›æ„ç‰¹æ•ˆåŠ¨ç”» */
            @keyframes snowFall {
                0% {
                    transform: translate3d(0, -10vh, 0) rotate(0deg);
                    opacity: 0;
                }
                10% { opacity: 1; }
                100% {
                    transform: translate3d(var(--dx), 110vh, 0) rotate(360deg);
                    opacity: 0;
                }
            }

            @keyframes heartFly {
                0% { 
                    transform: translate(-50%, -50%) scale(0.3) rotate(0deg);
                    opacity: 1;
                }
                100% { 
                    transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1) rotate(var(--rot));
                    opacity: 0;
                }
            }
            
            @keyframes petalFall {
                0% { 
                    transform: translateY(0) rotate(0deg);
                    opacity: 0;
                }
                10% {
                    opacity: 1;
                }
                100% { 
                    transform: translateY(100vh) translateX(var(--sway)) rotate(360deg);
                    opacity: 0;
                }
            }
            
            @keyframes floatUp {
                0% { 
                    transform: translateX(-50%) translateY(0) scale(0.5);
                    opacity: 0;
                }
                20% { 
                    transform: translateX(-50%) translateY(-20px) scale(1.1);
                    opacity: 1;
                }
                80% { 
                    transform: translateX(-50%) translateY(-80px) scale(1);
                    opacity: 1;
                }
                100% { 
                    transform: translateX(-50%) translateY(-120px) scale(0.8);
                    opacity: 0;
                }
            }
            
            @keyframes coinDrop {
                0% { 
                    transform: translateY(0) rotateY(0deg);
                    opacity: 0;
                }
                10% {
                    opacity: 1;
                }
                100% { 
                    transform: translateY(100vh) rotateY(var(--spin));
                    opacity: 0.3;
                }
            }

            @keyframes giftDrop {
                0% {
                    transform: translate3d(0, 0, 0) rotate(0deg);
                    opacity: 0;
                }
                10% { opacity: 1; }
                100% {
                    transform: translate3d(var(--dx), 110vh, 0) rotate(var(--spin));
                    opacity: 0.25;
                }
            }
            
            @keyframes starSpiral {
                0% { 
                    transform: translate(-50%, -50%) rotate(0deg);
                    opacity: 0;
                }
                30% {
                    opacity: 1;
                }
                100% { 
                    transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) rotate(720deg);
                    opacity: 0;
                }
            }
            
            @keyframes gemSplash {
                0% { 
                    transform: translate(-50%, -50%) scale(0.5) rotate(0deg);
                    opacity: 1;
                }
                100% { 
                    transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1.2) rotate(180deg);
                    opacity: 0;
                }
            }
            
            @keyframes vortexSpin {
                0% { 
                    transform: translate(-50%, -50%) scale(0.3) rotate(0deg);
                    opacity: 0;
                }
                30% {
                    opacity: 0.8;
                }
                100% { 
                    transform: translate(-50%, -50%) scale(3) rotate(720deg);
                    opacity: 0;
                }
            }
            
            @keyframes vortexSpinReverse {
                0% { 
                    transform: translate(-50%, -50%) scale(0.5) rotate(0deg);
                    opacity: 0;
                }
                30% {
                    opacity: 1;
                }
                100% { 
                    transform: translate(-50%, -50%) scale(2) rotate(-540deg);
                    opacity: 0;
                }
            }

            @keyframes santaFly {
                0% { transform: translate3d(0, 0, 0) scale(1); opacity: 0; }
                5% { opacity: 1; }
                90% { opacity: 1; }
                100% { transform: translate3d(140vw, -10vh, 0) scale(1.05); opacity: 0; }
            }

            @keyframes santaSpark {
                0% { transform: translate3d(0, 0, 0) scale(0.4); opacity: 0; }
                20% { opacity: 1; }
                100% { transform: translate3d(120px, 40px, 0) scale(1.2); opacity: 0; }
            }
        `;
        document.head.appendChild(effectStyles);

        // æ£€æµ‹ iOS ç‰ˆæœ¬ï¼ˆç”¨äºå…¼å®¹æ€§åˆ¤æ–­ï¼‰
        function getIOSVersion() {
            const match = navigator.userAgent.match(/OS (\d+)_(\d+)/);
            if (match) {
                return parseFloat(match[1] + '.' + match[2]);
            }
            return null;
        }


        // --- è§†è§‰è¯†åˆ«ç±» (ä½¿ç”¨ GestureRecognizer) ---
        class Vision {
            constructor() {
                this.video = document.getElementById('webcam');
                this.gestureRecognizer = null;
                this.lastVideoTime = -1;
                this.statusEl = document.getElementById('ai-status');
                this.cursor = document.getElementById('hand-cursor');
                this.lastDetectedGesture = null;
                this.gestureHoldCounter = 0;
                this._easter = { seq: [], lastAt: 0 };
                // ä¸å†è‡ªåŠ¨è°ƒç”¨ init()ï¼Œç”±ç”¨æˆ·é€‰æ‹©åæ‰‹åŠ¨è§¦å‘
            }

            async init() {
                try {
                    this.statusEl.innerText = "Loading AI Model...";

                    // æ£€æµ‹ iOS ç‰ˆæœ¬ï¼ˆç”¨äºé€‰æ‹© delegateï¼‰
                    const iosVersion = getIOSVersion();
                    const isOldIOS = iosVersion && iosVersion < 17;

                    // åªä½¿ç”¨æœ¬åœ° WASM æ–‡ä»¶ï¼ˆä¸ä¾èµ–å¤–éƒ¨CDNï¼Œç¡®ä¿ä¸­å›½ç”¨æˆ·å¯è®¿é—®ï¼‰
                    const vision = await FilesetResolver.forVisionTasks("./libs/mediapipe/wasm");

                    // é€‰æ‹© delegateï¼ˆä½ç‰ˆæœ¬ iOS ç”¨ CPUï¼‰
                    let useDelegate = isOldIOS ? "CPU" : "GPU";

                    // å°è¯•åˆ›å»º GestureRecognizerï¼Œå¦‚æœå¤±è´¥åˆ™å›é€€åˆ° CPU æ¨¡å¼
                    try {
                        this.gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: `hand_models/gesture_recognizer.task`,
                                delegate: useDelegate
                            },
                            runningMode: "VIDEO",
                            numHands: 1
                        });
                    } catch (delegateError) {
                        // GPU æ¨¡å¼å¤±è´¥ï¼Œå°è¯• CPU å›é€€
                        if (useDelegate === "GPU") {
                            console.warn("GPU delegate failed, trying CPU fallback:", delegateError);
                            useDelegate = "CPU";
                            this.gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                                baseOptions: {
                                    modelAssetPath: `hand_models/gesture_recognizer.task`,
                                    delegate: "CPU"
                                },
                                runningMode: "VIDEO",
                                numHands: 1
                            });
                        } else {
                            throw delegateError; // CPU ä¹Ÿå¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
                        }
                    }

                    // è®°å½•æ˜¯å¦ä¸ºä½æ€§èƒ½æ¨¡å¼ï¼ˆç”¨äºåç»­å¸§ç‡å’Œæ—‹è½¬é€Ÿåº¦è°ƒæ•´ï¼‰
                    this._isLowPerformance = isOldIOS || useDelegate === "CPU";
                    STATE.isLowPerformance = this._isLowPerformance;  // åŒæ­¥åˆ°å…¨å±€çŠ¶æ€

                    const modeInfo = useDelegate === "CPU" ? " (å…¼å®¹æ¨¡å¼)" : "";
                    this.statusEl.innerText = "AI Ready" + modeInfo;
                    this.statusEl.style.color = "#4ff";
                    console.log(`GestureRecognizer initialized with ${useDelegate} delegate`);
                    await this.startWebcam();
                } catch (e) {
                    console.warn("AI Init Failed:", e);
                    this.statusEl.innerText = "AI Failed. Mouse Mode."; this.statusEl.style.color = "#f44";
                    // é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œè®©å¤–éƒ¨ catch å¤„ç†
                    throw e;
                }
            }

            startWebcam() {
                return new Promise((resolve, reject) => {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        this.statusEl.innerText = "Webcam not supported.";
                        this.statusEl.style.color = "#f44";
                        reject(new Error('MediaDevices API not supported'));
                        return;
                    }
                    // Mobile-friendly constraints: prefer user-facing camera and reasonable resolution for performance.
                    const videoConstraints = isMobile ? {
                        facingMode: 'user',
                        width: { ideal: 480 },
                        height: { ideal: 360 }
                    } : {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    };

                    navigator.mediaDevices.getUserMedia({ video: videoConstraints }).then((stream) => {
                        this.video.srcObject = stream;

                        this.video.addEventListener("loadeddata", () => {
                            this.predict();
                            resolve();
                        }, { once: true });
                    }).catch(e => {
                        this.statusEl.innerText = "Webcam Denied.";
                        this.statusEl.style.color = "#f44";
                        reject(e);
                    });
                });
            }

            predict() {
                if (!this.gestureRecognizer) return;

                // æ™ºèƒ½èŠ‚æµï¼šæ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´è¯†åˆ«å¸§ç‡
                // - ä½æ€§èƒ½è®¾å¤‡ï¼ˆéSIMD/æ—§iOSï¼‰: ~15 FPS (66msé—´éš”)
                // - é«˜æ€§èƒ½ç§»åŠ¨ç«¯: ~60 FPS (16msé—´éš”)
                // - æ¡Œé¢ç«¯: ä¸é™åˆ¶
                const now = performance.now();
                if (isMobile || this._isLowPerformance) {
                    if (!this._lastPredictTime) this._lastPredictTime = 0;
                    const frameInterval = this._isLowPerformance ? 66 : 16; // 15 FPS vs 60 FPS
                    if (now - this._lastPredictTime < frameInterval) {
                        requestAnimationFrame(() => this.predict());
                        return;
                    }
                    this._lastPredictTime = now;
                }

                if (this.video.currentTime !== this.lastVideoTime) {
                    this.lastVideoTime = this.video.currentTime;
                    const results = this.gestureRecognizer.recognizeForVideo(this.video, now);

                    if (results.landmarks && results.landmarks.length > 0) {
                        this.cursor.style.display = 'block';
                        this.processGestures(results);
                    } else {
                        // å¦‚æœæ‰‹ç§»å‡ºç”»é¢ï¼Œå¼ºåˆ¶åˆ¹è½¦
                        STATE.rotationVelocity.x = lerp(STATE.rotationVelocity.x, 0, 0.2);
                        STATE.rotationVelocity.y = lerp(STATE.rotationVelocity.y, 0, 0.2);
                        this.cursor.style.display = 'none';
                    }
                }
                requestAnimationFrame(() => this.predict());
            }

            processGestures(results) {
                const landmarks = results.landmarks[0];
                const palm = landmarks[9];

                // 1. æ›´æ–°å‡†æ˜Ÿ
                const screenX = palm.x * window.innerWidth;
                const screenY = palm.y * window.innerHeight;
                this.cursor.style.left = `${screenX}px`;
                this.cursor.style.top = `${screenY}px`;

                // ä¿å­˜å½“å‰å±å¹•ä½ç½®
                this.currentScreenX = screenX;
                this.currentScreenY = screenY;

                // èŠ‚æµï¼šæ¯5å¸§æ‰æ›´æ–°æœ€è¿‘çš„ç…§ç‰‡
                this._photoUpdateCounter = (this._photoUpdateCounter || 0) + 1;
                if (this._photoUpdateCounter >= 5) {
                    this._photoUpdateCounter = 0;
                    STATE.hoveredPhoto = app.particles.findNearestPhoto(screenX, screenY, app.camera);
                }

                // 2. æ—‹è½¬æ§åˆ¶ - ä½¿ç”¨é…ç½®çš„çµæ•åº¦ï¼ˆç§»åŠ¨ç«¯æ›´é«˜ï¼‰
                const handX = (palm.x - 0.5) * 2;
                const handY = (palm.y - 0.5) * 2;
                const { deadZone, sensitivityX, sensitivityY } = CONFIG.gesture;

                if (STATE.mode === 'FOCUS') {
                    STATE.rotationVelocity.x = lerp(STATE.rotationVelocity.x, 0, 0.15);
                    STATE.rotationVelocity.y = lerp(STATE.rotationVelocity.y, 0, 0.15);
                    this.cursor.classList.add('safe-zone');
                    this.cursor.classList.remove('active-zone');
                } else if (STATE.mode === 'SCATTER' || STATE.mode === 'TREE') {
                    if (Math.abs(handX) > deadZone) {
                        STATE.rotationVelocity.x = handX * sensitivityX;
                        this.cursor.classList.add('active-zone');
                        this.cursor.classList.remove('safe-zone');
                    } else {
                        // In dead zone: smoothly decay to stop (keep consistent with Y axis behavior)
                        STATE.rotationVelocity.x = lerp(STATE.rotationVelocity.x, 0, 0.02);
                        this.cursor.classList.add('safe-zone');
                        this.cursor.classList.remove('active-zone');
                    }
                    if (Math.abs(handY) > deadZone) {
                        STATE.rotationVelocity.y = handY * sensitivityY;
                    } else {
                        STATE.rotationVelocity.y = lerp(STATE.rotationVelocity.y, 0, 0.05);
                    }
                }

                // 3. æ‰‹åŠ¿è¯†åˆ« - ç›´æ¥ä½¿ç”¨æ¨¡å‹è¾“å‡ºçš„æ‰‹åŠ¿åç§°ï¼
                let modelGesture = 'None';
                if (results.gestures && results.gestures.length > 0 && results.gestures[0].length > 0) {
                    modelGesture = results.gestures[0][0].categoryName;
                }

                // æ˜ å°„æ¨¡å‹æ‰‹åŠ¿åˆ°åº”ç”¨æ¨¡å¼
                // æ¨¡å‹æ”¯æŒ: Closed_Fist, Open_Palm, Pointing_Up, Thumb_Down, Thumb_Up, Victory, ILoveYou
                let currentGesture = null;
                const gestureMap = {
                    'Closed_Fist': 'TREE',
                    'Open_Palm': 'SCATTER',
                    'Pointing_Up': 'FOCUS'    // å‘ä¸ŠæŒ‡ â†’ èšç„¦ç…§ç‰‡
                };

                // ç‰¹æ®Šæ‰‹åŠ¿å¤„ç†ï¼ˆä¸æ”¹å˜æ¨¡å¼ï¼Œä»…è§¦å‘ç‰¹æ•ˆï¼‰
                const specialGestures = ['ILoveYou', 'Thumb_Up', 'Victory', 'Thumb_Down'];
                const isSpecialGesture = specialGestures.includes(modelGesture);

                currentGesture = gestureMap[modelGesture] || null;

                // 4. è§¦å‘é€»è¾‘ï¼ˆå¢åŠ ç¡®è®¤å¸§æ•°ï¼‰
                const requiredFrames = 5;  // æ¨¡å‹æ›´å‡†ç¡®ï¼Œå¯ä»¥å‡å°‘ç¡®è®¤å¸§æ•°

                // å¤„ç†ç‰¹æ®Šæ‰‹åŠ¿ï¼ˆè§¦å‘ç‰¹æ•ˆï¼‰
                if (isSpecialGesture) {
                    // ğŸ¤Ÿ ILoveYou - çƒŸèŠ±/å¿ƒå½¢/ç…§ç‰‡çˆ±å¿ƒ
                    if (modelGesture === 'ILoveYou') {
                        if (app.gestureEffects) {
                            app.gestureEffects.triggerILoveYou(STATE.mode);
                            document.getElementById('debug-mode').innerHTML = `Effect: ğŸ¤Ÿ ${STATE.mode === 'TREE' ? 'ğŸ† çƒŸèŠ±' : STATE.mode === 'SCATTER' ? 'â¤ï¸ å¿ƒå½¢' : 'ğŸ’ çˆ±å¿ƒ'}<br>Mode: ${STATE.mode}`;
                        }
                    }

                    // ğŸ‘ Thumb_Up - å½©è™¹èºæ—‹/é—ªçƒ/ç‚¹èµç‰¹æ•ˆ
                    if (modelGesture === 'Thumb_Up') {
                        if (app.gestureEffects) {
                            app.gestureEffects.triggerThumbUp(STATE.mode);
                            document.getElementById('debug-mode').innerHTML = `Effect: ğŸ‘ ${STATE.mode === 'TREE' ? 'ğŸŒˆ å½©è™¹èºæ—‹' : STATE.mode === 'SCATTER' ? 'âœ¨ å½©è™¹é—ªçƒ' : 'ğŸ‰ ç‚¹èµ'}<br>Mode: ${STATE.mode}`;
                        }
                    }

                    // âœŒï¸ Victory - åŒå…‰æŸ/åˆ†è£‚æ—‹è½¬/èƒœåˆ©å…‰èŠ’
                    if (modelGesture === 'Victory') {
                        if (app.gestureEffects) {
                            app.gestureEffects.triggerVictory(STATE.mode);
                            document.getElementById('debug-mode').innerHTML = `Effect: âœŒï¸ ${STATE.mode === 'TREE' ? 'âš¡ åŒå…‰æŸ' : STATE.mode === 'SCATTER' ? 'ğŸ’« åˆ†è£‚æ—‹è½¬' : 'ğŸ”® èƒœåˆ©å…‰èŠ’'}<br>Mode: ${STATE.mode}`;
                        }
                    }

                    // ğŸ‘ Thumb_Down - å†°é›ªé£æš´/å¯’å…‰
                    if (modelGesture === 'Thumb_Down') {
                        if (app.gestureEffects) {
                            app.gestureEffects.triggerThumbDown(STATE.mode);
                            document.getElementById('debug-mode').innerHTML = `Effect: ğŸ‘ ${STATE.mode === 'TREE' ? 'â„ï¸ å†°é›ªé£æš´' : STATE.mode === 'SCATTER' ? 'ğŸŒ¨ï¸ é›ªå¹•' : 'ğŸ§Š å†·å…‰'}<br>Mode: ${STATE.mode}`;
                        }
                    }

                    // Hidden combo Easter Egg (no UI): ğŸ¤Ÿ -> âœŒï¸ -> ğŸ‘ within 6s triggers Santa flyby
                    try {
                        const nowCombo = performance.now();
                        if (nowCombo - this._easter.lastAt > 6000) this._easter.seq = [];
                        this._easter.lastAt = nowCombo;
                        this._easter.seq.push(modelGesture);
                        if (this._easter.seq.length > 3) this._easter.seq.shift();
                        if (this._easter.seq[0] === 'ILoveYou' && this._easter.seq[1] === 'Victory' && this._easter.seq[2] === 'Thumb_Up') {
                            if (app.gestureEffects) app.gestureEffects.triggerSantaFlyby();
                            this._easter.seq = [];
                        }
                        // Hidden combo Easter Egg: ğŸ‘ğŸ‘ğŸ‘ within ~4s triggers Gift Rain
                        if (this._easter.seq[0] === 'Thumb_Up' && this._easter.seq[1] === 'Thumb_Up' && this._easter.seq[2] === 'Thumb_Up') {
                            if (app.gestureEffects) app.gestureEffects.triggerGiftRain();
                            this._easter.seq = [];
                        }
                        // Hidden combo Easter Egg: âœŒï¸âœŒï¸ğŸ¤Ÿ cycles theme (no UI)
                        if (this._easter.seq[0] === 'Victory' && this._easter.seq[1] === 'Victory' && this._easter.seq[2] === 'ILoveYou') {
                            if (app && typeof app.nextTheme === 'function') app.nextTheme();
                            this._easter.seq = [];
                        }
                    } catch { }
                }

                if (currentGesture && currentGesture === this.lastDetectedGesture) {
                    this.gestureHoldCounter++;
                } else {
                    this.gestureHoldCounter = 0;
                    this.lastDetectedGesture = currentGesture;
                }

                const now2 = performance.now();

                // ä» FOCUS é€€å‡ºåæœ‰æ›´é•¿çš„å†·å´æœŸï¼ˆ2ç§’ï¼‰ï¼Œé˜²æ­¢ç”¨æˆ·æ”¶æ‰‹æ¡æ‹³æ„å¤–è§¦å‘ TREE
                const cooldown = STATE.justExitedFocus ? 2000 : 600;

                if (this.gestureHoldCounter > requiredFrames &&
                    currentGesture &&
                    currentGesture !== STATE.mode &&
                    (now2 - STATE.lastModeChangeTime > cooldown)) {

                    // æ¸…é™¤å†·å´æ ‡è®°
                    STATE.justExitedFocus = false;

                    // è¿›å…¥ FOCUS å‰è®°ä½å½“å‰æ¨¡å¼
                    if (currentGesture === 'FOCUS') {
                        STATE.previousMode = STATE.mode;
                    }

                    // ä» FOCUS é€€å‡ºæ—¶ï¼šå›åˆ°ä¹‹å‰çš„æ¨¡å¼ï¼Œè€Œä¸æ˜¯è·Ÿéšå½“å‰æ‰‹åŠ¿
                    // è¿™æ · SCATTER â†’ FOCUS â†’ æ¡æ‹³ = å›åˆ° SCATTERï¼Œä¸ä¼šè·³åˆ° TREE
                    let nextMode = currentGesture;
                    if (STATE.mode === 'FOCUS' && currentGesture !== 'FOCUS') {
                        nextMode = STATE.previousMode || 'TREE';
                        STATE.justExitedFocus = true;  // æ ‡è®°åˆšä» FOCUS é€€å‡º
                    }

                    STATE.mode = nextMode;
                    STATE.lastModeChangeTime = now2;

                    // èšç„¦æ—¶æ‰¾æœ€è¿‘çš„ç…§ç‰‡
                    if (STATE.mode === 'FOCUS') {
                        STATE.targetPhoto = app.particles.findNearestPhoto(
                            this.currentScreenX,
                            this.currentScreenY,
                            app.camera
                        );
                    }

                    const gestureNames = { 'FOCUS': 'ğŸ¤ Focus', 'TREE': 'âœŠ Fist', 'SCATTER': 'ğŸ–ï¸ Open' };
                    document.getElementById('debug-mode').innerHTML = `Mode: ${STATE.mode}\u003cbr\u003eGesture: ${modelGesture}`;
                }

                // å®æ—¶æ˜¾ç¤ºæ£€æµ‹åˆ°çš„æ‰‹åŠ¿ï¼ˆè°ƒè¯•ç”¨ï¼‰
                document.getElementById('gesture-name').innerText = modelGesture;
            }
        }

        // --- App ---
        class App {
            constructor() {
                this.setupUI();
                this.container = document.createElement('div'); document.body.appendChild(this.container);
                // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šç¦ç”¨æŠ—é”¯é½¿ï¼Œé™åˆ¶åƒç´ æ¯”æå‡æ€§èƒ½
                this.renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
                // é™åˆ¶ç§»åŠ¨ç«¯åƒç´ æ¯”ä¸ºæœ€å¤š2.0ï¼Œé¿å…é«˜åˆ†è¾¨ç‡å±å¹•å¡é¡¿
                this.maxPixelRatio = isMobile ? 2.0 : window.devicePixelRatio;
                // Adaptive rendering resolution (no UI): start high, degrade if FPS drops
                const initialPixelRatio = Math.min(window.devicePixelRatio, this.maxPixelRatio);
                this._perf = {
                    emaDt: 1 / 60,
                    lastAdjustMs: performance.now(),
                    pixelRatio: initialPixelRatio,
                    minPixelRatio: isMobile ? 0.75 : 0.9
                };
                this.renderer.setPixelRatio(this._perf.pixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.toneMapping = THREE.ReinhardToneMapping; this.renderer.toneMappingExposure = 2.2;
                this.container.appendChild(this.renderer.domElement);

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
                this.camera.position.set(0, 2, 50);

                const pmrem = new THREE.PMREMGenerator(this.renderer);
                this.scene.environment = pmrem.fromScene(new RoomEnvironment(this.renderer), 0.04).texture;
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(this.ambientLight);
                this.keyLight = new THREE.SpotLight(CONFIG.colors.gold, 1200);
                this.keyLight.position.set(30, 40, 40);
                this.keyLight.castShadow = true;
                this.scene.add(this.keyLight);
                this.fillLight = new THREE.SpotLight(0x4444ff, 600);
                this.scene.add(this.fillLight);

                this.particles = new ParticleSystem(this.scene, this.camera);
                this._theme = THEMES[THEME_INDEX] || THEMES[0];
                this._bloomBase = this._theme.bloomBase ?? CONFIG.bloom.strength;
                try { this.particles.applyTheme(this._theme); } catch { }
                try {
                    if (this.keyLight?.color) this.keyLight.color.setHex(this._theme.lights.key);
                    if (this.fillLight?.color) this.fillLight.color.setHex(this._theme.lights.fill);
                } catch { }

                // åˆå§‹åŒ–æ‰‹åŠ¿ç‰¹æ•ˆç³»ç»Ÿ
                this.gestureEffects = new GestureEffects(this.scene, this.particles);
                this.lastTime = performance.now();

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), this._bloomBase, CONFIG.bloom.radius, CONFIG.bloom.threshold);
                this.composer.addPass(this.bloomPass);
                this.composer.addPass(new OutputPass());

                // Vision å®ä¾‹ç°åœ¨ç”±ç”¨æˆ·é€‰æ‹©åæ‰åˆå§‹åŒ–
                this.vision = null;

                // Loader ç°åœ¨ç”±ç”¨æˆ·é€‰æ‹©æ¨¡å¼åæ§åˆ¶
                this._boundResize = this.onWindowResize.bind(this);
                window.addEventListener('resize', this._boundResize);
                // åˆå§‹åŒ–æ—¶åº”ç”¨å“åº”å¼ç›¸æœºè®¾ç½®
                this.onWindowResize();

                // é¼ æ ‡æ‹–æ‹½æ—‹è½¬
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                // Pointer state (mouse/touch) for unified rAF-driven updates
                this.pointerX = 0;
                this.pointerY = 0;
                this.pointerActive = false;
                this.pointerDirty = false;
                this._hoverUpdateCounter = 0;

                // Multi-touch (pinch/twist) state
                this._pinch = {
                    active: false,
                    startDist: 0,
                    startAngle: 0,
                    startZ: 0,
                    lastAngle: 0
                };
                this._zoom = {
                    minZ: 35,
                    maxZ: 90
                };

                document.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.pointerX = e.clientX;
                    this.pointerY = e.clientY;
                    this.pointerActive = true;
                    this.pointerDirty = true;
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    // åœæ­¢æ‹–æ‹½æ—¶å‡é€Ÿ
                    STATE.rotationVelocity.x = lerp(STATE.rotationVelocity.x, 0, 0.3);
                    STATE.rotationVelocity.y = lerp(STATE.rotationVelocity.y, 0, 0.3);
                });

                document.addEventListener('mousemove', (e) => {
                    // é¼ æ ‡æ¨¡å¼ï¼šåªè®°å½•ä½ç½®ï¼Œå®é™… UI/è®¡ç®—åœ¨ animate ä¸­ç»Ÿä¸€èŠ‚æµ
                    if (!this.vision || !this.vision.gestureRecognizer) {
                        this.pointerX = e.clientX;
                        this.pointerY = e.clientY;
                        this.pointerActive = true;
                        this.pointerDirty = true;
                    }

                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMouseX;
                        const deltaY = e.clientY - this.lastMouseY;
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                        // æ‹–æ‹½æ§åˆ¶æ—‹è½¬ï¼ˆæ‰€æœ‰æ¨¡å¼éƒ½å¯ç”¨ï¼‰
                        STATE.rotationVelocity.x = deltaX * 0.1;
                        STATE.rotationVelocity.y = deltaY * 0.05;
                    }
                });

                // ç§»é™¤äº†å•å‡»èšç„¦é€»è¾‘ï¼Œä¿ç•™åŸæœ‰çš„åŒå‡»åˆ‡æ¢æ¨¡å¼

                // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆæ‰‹æœºç«¯ï¼‰
                document.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.isDragging = true;
                        this.lastMouseX = e.touches[0].clientX;
                        this.lastMouseY = e.touches[0].clientY;
                        if (!this.vision || !this.vision.gestureRecognizer) {
                            this.pointerX = e.touches[0].clientX;
                            this.pointerY = e.touches[0].clientY;
                            this.pointerActive = true;
                            this.pointerDirty = true;
                        }
                    } else if (e.touches.length === 2) {
                        // Start pinch/twist
                        this.isDragging = false;
                        const x0 = e.touches[0].clientX, y0 = e.touches[0].clientY;
                        const x1 = e.touches[1].clientX, y1 = e.touches[1].clientY;
                        const dx = x1 - x0, dy = y1 - y0;
                        const dist = Math.hypot(dx, dy) || 1;
                        const ang = Math.atan2(dy, dx) || 0;
                        this._pinch.active = true;
                        this._pinch.startDist = dist;
                        this._pinch.startAngle = ang;
                        this._pinch.lastAngle = ang;
                        this._pinch.startZ = this.camera.position.z;
                    }
                }, { passive: true });

                document.addEventListener('touchend', () => {
                    this.isDragging = false;
                    this._pinch.active = false;
                    STATE.rotationVelocity.x = lerp(STATE.rotationVelocity.x, 0, 0.3);
                    STATE.rotationVelocity.y = lerp(STATE.rotationVelocity.y, 0, 0.3);
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    if (this.isDragging && e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - this.lastMouseX;
                        const deltaY = e.touches[0].clientY - this.lastMouseY;
                        this.lastMouseX = e.touches[0].clientX;
                        this.lastMouseY = e.touches[0].clientY;
                        STATE.rotationVelocity.x = deltaX * 0.1;
                        STATE.rotationVelocity.y = deltaY * 0.05;
                        if (!this.vision || !this.vision.gestureRecognizer) {
                            this.pointerX = e.touches[0].clientX;
                            this.pointerY = e.touches[0].clientY;
                            this.pointerActive = true;
                            this.pointerDirty = true;
                        }
                    } else if (e.touches.length === 2) {
                        // Pinch zoom + gentle twist rotate (no UI)
                        // Need preventDefault to avoid browser page-zoom/scroll while interacting.
                        e.preventDefault();
                        const x0 = e.touches[0].clientX, y0 = e.touches[0].clientY;
                        const x1 = e.touches[1].clientX, y1 = e.touches[1].clientY;
                        const dx = x1 - x0, dy = y1 - y0;
                        const dist = Math.hypot(dx, dy) || 1;
                        const ang = Math.atan2(dy, dx) || 0;

                        if (!this._pinch.active) {
                            this._pinch.active = true;
                            this._pinch.startDist = dist;
                            this._pinch.startAngle = ang;
                            this._pinch.lastAngle = ang;
                            this._pinch.startZ = this.camera.position.z;
                        }

                        const scale = this._pinch.startDist / dist;
                        const targetZ = Math.min(this._zoom.maxZ, Math.max(this._zoom.minZ, this._pinch.startZ * scale));
                        // Smooth zoom to avoid jitter
                        this.camera.position.z = lerp(this.camera.position.z, targetZ, 0.25);

                        // Twist -> Y rotation velocity
                        const deltaAng = ang - this._pinch.lastAngle;
                        this._pinch.lastAngle = ang;
                        if (Math.abs(deltaAng) > 0.001) {
                            STATE.rotationVelocity.x = deltaAng * 8; // tuned for touch
                        }
                    }
                }, { passive: false });

                // æ»šè½®åˆ‡æ¢æ¨¡å¼
                document.addEventListener('wheel', (e) => {
                    const now = performance.now();
                    if (now - STATE.lastModeChangeTime > 300) {
                        const modes = ['TREE', 'SCATTER', 'FOCUS'];
                        const dir = e.deltaY > 0 ? 1 : -1;
                        const idx = (modes.indexOf(STATE.mode) + dir + 3) % 3;
                        STATE.mode = modes[idx];
                        STATE.lastModeChangeTime = now;
                        if (STATE.mode === 'FOCUS') STATE.targetPhoto = this.particles.pickRandomPhoto();
                        const names = { 'TREE': 'âœŠ Tree', 'SCATTER': 'ğŸ–ï¸ Scatter', 'FOCUS': 'ğŸ¤ Focus' };
                        document.getElementById('debug-mode').innerHTML = `Mode: ${STATE.mode}<br>${names[STATE.mode]}`;
                    }
                    e.preventDefault();
                }, { passive: false });

                // ç‚¹å‡»åˆ‡æ¢æ¨¡å¼ï¼ˆæ— æ‘„åƒå¤´æ—¶ï¼‰
                document.addEventListener('dblclick', () => {
                    const now = performance.now();
                    if (now - STATE.lastModeChangeTime > 500) {
                        const m = ['TREE', 'SCATTER', 'FOCUS'];
                        STATE.mode = m[(m.indexOf(STATE.mode) + 1) % m.length];
                        STATE.lastModeChangeTime = now;
                        if (STATE.mode === 'FOCUS') STATE.targetPhoto = this.particles.pickRandomPhoto();
                        const names = { 'TREE': 'âœŠ Tree', 'SCATTER': 'ğŸ–ï¸ Scatter', 'FOCUS': 'ğŸ¤ Focus' };
                        document.getElementById('debug-mode').innerHTML = `Mode: ${STATE.mode}<br>${names[STATE.mode]}`;
                    }
                });
                // Avoid per-frame bind allocations
                this._boundAnimate = this.animate.bind(this);
                this._boundAnimate();
            }

            nextTheme() {
                THEME_INDEX = (THEME_INDEX + 1) % THEMES.length;
                this._theme = THEMES[THEME_INDEX] || THEMES[0];
                this._bloomBase = this._theme.bloomBase ?? CONFIG.bloom.strength;
                try { this.particles.applyTheme(this._theme); } catch { }
                try {
                    if (this.keyLight?.color) this.keyLight.color.setHex(this._theme.lights.key);
                    if (this.fillLight?.color) this.fillLight.color.setHex(this._theme.lights.fill);
                } catch { }
            }

            setupUI() {
                // é”®ç›˜å¿«æ·é”®
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'h' || e.key === 'H') {
                        document.getElementById('ui-container').classList.toggle('ui-hidden');
                    }
                    if (e.key === 'm' || e.key === 'M') {
                        // silent music toggle
                        try { audio.toggleMute(); } catch { }
                    }
                    // 1/2/3 åˆ‡æ¢æ¨¡å¼ï¼ˆæ²¡æœ‰æ‘„åƒå¤´æ—¶ä¹Ÿå¯ç”¨ï¼‰
                    if (e.key === '1') this.switchMode('TREE');
                    if (e.key === '2') this.switchMode('SCATTER');
                    if (e.key === '3') this.switchMode('FOCUS');
                });
            }

            switchMode(mode) {
                const now = performance.now();
                if (now - STATE.lastModeChangeTime > 500) {
                    STATE.mode = mode;
                    STATE.lastModeChangeTime = now;
                    if (mode === 'FOCUS') STATE.targetPhoto = this.particles.pickRandomPhoto();
                    const names = { 'TREE': 'âœŠ', 'SCATTER': 'ğŸ–ï¸', 'FOCUS': 'ğŸ¤' };
                    document.getElementById('debug-mode').innerHTML = `Mode: ${mode}<br>Key: ${names[mode]}`;
                }
            }
            onWindowResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const aspect = w / h;

                // æ ¹æ®å±å¹•å°ºå¯¸è°ƒæ•´ç›¸æœº
                this.camera.aspect = aspect;

                // ç«–å±ï¼ˆæ‰‹æœºï¼‰éœ€è¦æ‹‰è¿œç›¸æœº/å¢å¤§FOVæ‰èƒ½çœ‹åˆ°å®Œæ•´åœ£è¯æ ‘
                if (aspect < 1) {
                    // ç«–å±ï¼šè°ƒæ•´FOVå’Œè·ç¦»
                    this.camera.fov = 55;
                    this.camera.position.z = 60;
                } else if (aspect < 1.5) {
                    // æ¥è¿‘æ­£æ–¹å½¢ï¼ˆiPadç­‰ï¼‰
                    this.camera.fov = 50;
                    this.camera.position.z = 55;
                } else {
                    // å®½å±ï¼ˆç”µè„‘ï¼‰
                    this.camera.fov = 45;
                    this.camera.position.z = 50;
                }

                this.camera.updateProjectionMatrix();
                // Pixel ratio can change on mobile orientation / zoom changes
                const maxAllowed = Math.min(window.devicePixelRatio, this.maxPixelRatio);
                if (this._perf.pixelRatio > maxAllowed) this._perf.pixelRatio = maxAllowed;
                this.renderer.setPixelRatio(this._perf.pixelRatio);
                this.renderer.setSize(w, h);
                this.composer.setSize(w, h);
            }
            animate() {
                requestAnimationFrame(this._boundAnimate);
                const now = performance.now();
                const time = now * 0.001;
                const deltaTime = (now - this.lastTime) * 0.001;
                this.lastTime = now;

                // If tab is hidden, skip heavy work (browsers throttle RAF anyway, but this avoids spikes on resume)
                if (document.hidden) return;

                // æ›´æ–°ç²’å­ç³»ç»Ÿ
                this.particles.update(time);

                // æ›´æ–°ç‰¹æ•ˆ
                if (this.gestureEffects) this.gestureEffects.update(deltaTime, time);

                // Music-reactive subtle visuals (no UI): top star breathes with beat
                try {
                    const p = audio && typeof audio.getPulse === 'function' ? audio.getPulse() : 0;
                    if (this.particles && this.particles.topStar && this.particles.topStar.material) {
                        const m = this.particles.topStar.material;
                        // keep subtle (avoid flicker)
                        m.emissiveIntensity = 0.8 + p * 0.55;
                        this.particles.topStar.scale.setScalar(1 + p * 0.06);
                    }
                } catch { }

                // Mouse/touch mode: update cursor + hovered photo in rAF (avoids heavy work in event callbacks)
                if (!this.vision || !this.vision.gestureRecognizer) {
                    const cursor = document.getElementById('hand-cursor');
                    if (this.pointerActive) {
                        cursor.style.display = 'block';
                        cursor.style.left = `${this.pointerX}px`;
                        cursor.style.top = `${this.pointerY}px`;

                        // Only recompute nearest photo occasionally and only when pointer moved.
                        this._hoverUpdateCounter++;
                        if (this.pointerDirty && this._hoverUpdateCounter >= 10) {
                            this._hoverUpdateCounter = 0;
                            this.pointerDirty = false;
                            STATE.hoveredPhoto = this.particles.findNearestPhoto(this.pointerX, this.pointerY, this.camera);
                        }
                    } else {
                        cursor.style.display = 'none';
                    }
                }

                // --- Adaptive performance (no UI) ---
                // Exponential moving average of deltaTime to avoid reacting to single spikes.
                const dt = Math.min(Math.max(deltaTime, 0), 0.2);
                this._perf.emaDt = this._perf.emaDt * 0.92 + dt * 0.08;

                // Adjust roughly once per ~1.2s to avoid oscillation.
                if (now - this._perf.lastAdjustMs > 1200) {
                    this._perf.lastAdjustMs = now;
                    const maxAllowed = Math.min(window.devicePixelRatio, this.maxPixelRatio);

                    // Target: stay above ~50-55fps on mobile, ~55-60fps on desktop.
                    const slow = isMobile ? 0.022 : 0.020; // ~45fps vs ~50fps
                    const fast = isMobile ? 0.017 : 0.016; // ~58fps vs ~62fps

                    if (this._perf.emaDt > slow && this._perf.pixelRatio > this._perf.minPixelRatio) {
                        this._perf.pixelRatio = Math.max(this._perf.minPixelRatio, this._perf.pixelRatio - 0.15);
                        this.renderer.setPixelRatio(this._perf.pixelRatio);
                        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    } else if (this._perf.emaDt < fast && this._perf.pixelRatio < maxAllowed) {
                        this._perf.pixelRatio = Math.min(maxAllowed, this._perf.pixelRatio + 0.10);
                        this.renderer.setPixelRatio(this._perf.pixelRatio);
                        this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }

                    // Bloom intensity scales down slightly when resolution is reduced or device is low-performance.
                    if (this.bloomPass) {
                        const prNorm = this._perf.pixelRatio / Math.max(1, Math.min(this.maxPixelRatio, 2));
                        const lowPerf = STATE.isLowPerformance ? 0.85 : 1.0;
                        this.bloomPass.strength = (this._bloomBase ?? CONFIG.bloom.strength) * (0.75 + 0.25 * prNorm) * lowPerf;
                        this.bloomPass.radius = CONFIG.bloom.radius * (0.85 + 0.15 * prNorm);
                        this.bloomPass.threshold = CONFIG.bloom.threshold;
                    }
                }

                this.composer.render();
            }
        }
        const app = new App();

        // Best-effort cleanup on page unload (silent): release camera devices promptly.
        window.addEventListener('beforeunload', () => {
            try {
                const stream = app && app.vision && app.vision.video ? app.vision.video.srcObject : null;
                if (stream && stream.getTracks) {
                    stream.getTracks().forEach(t => { try { t.stop(); } catch { } });
                }
            } catch { }
        });

        // å…¨å±€å¯åŠ¨å‡½æ•°ï¼šå¯ç”¨æ‰‹åŠ¿æ§åˆ¶ï¼ˆå¤±è´¥æ—¶è‡ªåŠ¨é™çº§ï¼‰
        window.startWithGesture = function () {
            document.getElementById('tutorial-overlay').style.display = 'none';
            try { audio.arm(); audio.start(); } catch { }
            const loader = document.getElementById('loader');
            loader.style.display = 'flex';
            // åŠ è½½æ–‡å­—ç”± startAILoadTimeout ä¸­çš„è¿›åº¦ç³»ç»Ÿç»Ÿä¸€å¤„ç†

            // å¯åŠ¨AIåŠ è½½è¿›åº¦æ˜¾ç¤ºå’Œè®¡æ—¶å™¨
            startAILoadTimeout();

            app.vision = new Vision();
            app.vision.init().then(() => {
                clearAILoadTimeout();

                // åŠ è½½æˆåŠŸï¼šè¿›åº¦æ¡è·³åˆ°100%
                const progressBar = document.getElementById('loader-progress-bar');
                const loaderText = document.querySelector('.loader-text');
                const subtitle = document.getElementById('loader-subtitle');
                if (progressBar) progressBar.style.width = '100%';
                if (loaderText) loaderText.textContent = 'AI READY âœ“';
                if (subtitle) subtitle.textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨';

                // çŸ­æš‚æ˜¾ç¤ºæˆåŠŸçŠ¶æ€åæ¶ˆå¤±
                setTimeout(() => {
                    loader.style.opacity = 0;
                    setTimeout(() => loader.style.visibility = 'hidden', 1000);
                }, 500);

                // æ˜¾ç¤ºæç¤ºé¢æ¿
                document.getElementById('hint-panel').style.display = 'block';

                // æ˜¾ç¤ºåŠ¨æ€å¼•å¯¼æç¤º
                showGestureGuideHint();
            }).catch(err => {
                console.error('Vision startup failed:', err);
                clearAILoadTimeout();

                // å¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°é¼ æ ‡æ¨¡å¼
                loader.style.opacity = 0;
                setTimeout(() => {
                    loader.style.visibility = 'hidden';
                    window.startMouseOnly();

                    // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤º
                    let msg = 'âš ï¸ å¯åŠ¨å¤±è´¥ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        msg = 'ğŸ”’ æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    } else if (err.message && err.message.includes('MediaDevices API not supported')) {
                        msg = 'âš ï¸ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        msg = 'âš ï¸ æœªæ£€æµ‹åˆ°æ‘„åƒå¤´ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    } else if (err.toString().includes('constraints')) {
                        msg = 'âš ï¸ æ‘„åƒå¤´ä¸æ»¡è¶³è¦æ±‚ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    } else if (err.toString().includes('model') || err.toString().includes('wasm') || err.toString().includes('task')) {
                        msg = 'âš ï¸ AIæ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼';
                    }

                    // æ˜¾ç¤ºé™çº§æç¤º
                    const toast = document.createElement('div');
                    toast.style.cssText = `
                        position: fixed;
                        top: 20px; left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.85);
                        color: #ffaa00;
                        padding: 12px 24px;
                        border-radius: 25px;
                        border: 1px solid #ffaa00;
                        z-index: 1000;
                        font-family: sans-serif;
                        font-size: 14px;
                        pointer-events: none;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        white-space: nowrap;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                    `;
                    toast.innerHTML = msg;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                }, 500);
            });
        };

        // å…¨å±€å¯åŠ¨å‡½æ•°ï¼šä»…é¼ æ ‡æ¨¡å¼
        window.startMouseOnly = function () {
            document.getElementById('tutorial-overlay').style.display = 'none';
            try { audio.arm(); audio.start(); } catch { }
            document.getElementById('ai-status').innerHTML = 'é¼ æ ‡æ¨¡å¼ | Mouse Mode';
            document.getElementById('ai-status').style.color = '#aaa';
            // æ˜¾ç¤ºæç¤ºé¢æ¿
            document.getElementById('hint-panel').style.display = 'block';
        };

        // æ³¨æ„ï¼šstartAILoadTimeout å’Œ clearAILoadTimeout å·²åœ¨ä¸Šæ–¹æ™®é€š script ä¸­å®šä¹‰
        // è¿™é‡Œä¸å†é‡å¤å®šä¹‰ï¼Œé¿å…è¦†ç›–ä¼˜åŒ–åçš„ç‰ˆæœ¬

        // åŠ¨æ€å¼•å¯¼æç¤ºï¼šæ‰‹åŠ¿æ¨¡å¼æˆåŠŸå¯åŠ¨åæ˜¾ç¤º
        function showGestureGuideHint() {
            const hint = document.createElement('div');
            hint.id = 'gesture-guide-hint';
            hint.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,40,60,0.95));
                border: 2px solid #66ccff;
                border-radius: 20px;
                padding: 25px 40px;
                z-index: 300;
                text-align: center;
                font-family: Georgia, 'Times New Roman', serif;
                box-shadow: 0 0 40px rgba(100, 200, 255, 0.4), inset 0 0 20px rgba(100, 200, 255, 0.1);
                animation: guideHintPulse 2s ease-in-out infinite, guideHintFadeIn 0.5s ease-out;
            `;
            hint.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 10px; animation: handWave 1s ease-in-out infinite;">ğŸ‘‹</div>
                <div style="color: #66ccff; font-size: 20px; font-weight: bold; margin-bottom: 8px;">ç§»åŠ¨ä½ çš„æ‰‹æŒ</div>
                <div style="color: rgba(255,255,255,0.8); font-size: 14px;">åœ£è¯æ ‘ä¼šè·Ÿç€ä½ çš„æ‰‹æ—‹è½¬ï¼</div>
                <div style="color: rgba(255,255,255,0.5); font-size: 11px; margin-top: 10px;">â† ä¸Šä¸‹å·¦å³ç§»åŠ¨è¯•è¯•çœ‹ â†’</div>
            `;
            document.body.appendChild(hint);

            // æ·»åŠ åŠ¨ç”»æ ·å¼
            if (!document.getElementById('gesture-guide-styles')) {
                const styles = document.createElement('style');
                styles.id = 'gesture-guide-styles';
                styles.textContent = `
                    @keyframes guideHintPulse {
                        0%, 100% { box-shadow: 0 0 40px rgba(100, 200, 255, 0.4), inset 0 0 20px rgba(100, 200, 255, 0.1); }
                        50% { box-shadow: 0 0 60px rgba(100, 200, 255, 0.6), inset 0 0 30px rgba(100, 200, 255, 0.2); }
                    }
                    @keyframes guideHintFadeIn {
                        from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                    @keyframes handWave {
                        0%, 100% { transform: rotate(0deg); }
                        25% { transform: rotate(20deg); }
                        75% { transform: rotate(-20deg); }
                    }
                `;
                document.head.appendChild(styles);
            }

            // 5ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                hint.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                hint.style.opacity = '0';
                hint.style.transform = 'translate(-50%, -50%) scale(0.8)';
                setTimeout(() => hint.remove(), 500);
            }, 5000);

            // ç‚¹å‡»ä»»æ„ä½ç½®å…³é—­
            hint.addEventListener('click', () => {
                hint.style.transition = 'opacity 0.3s ease';
                hint.style.opacity = '0';
                setTimeout(() => hint.remove(), 300);
            });
        }

        // æç¤ºé¢æ¿æŠ˜å /å±•å¼€
        window.toggleHintPanel = function () {
            const content = document.getElementById('hint-content');
            const collapsed = document.getElementById('hint-collapsed');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                collapsed.style.display = 'none';
            } else {
                content.style.display = 'none';
                collapsed.style.display = 'block';
            }
        };
    </script>
</body>

</html>